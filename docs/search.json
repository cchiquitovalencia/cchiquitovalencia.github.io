[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cristian Chiquito Valencia",
    "section": "",
    "text": "Logistics, Specialist | Universidad del Valle (September 2019)\nIndustrial Engineer, B.S. | Universidad Icesi (February 2015)\n\n\n\nMaintenance Planner @ Grupo Integrado de Transporte Masivo S.A. (_Jul 2024 - Sep 2024)\n- Propose to the Maintenance Department improvement, recovery, and maintenance projects for the fleet, with technical information by component and system of the buses. - Plan maintenance for the fleet according to the established wear strategy, operational standards, considering the criticality of equipment, fleet age, and manufacturer manuals. - Generate monthly and annual budget information for the Maintenance area based on the maintenance plan and kilometer execution within the information system. - Plan resources required for the maintenance plan for the fleet (spare parts, labor, tools, vehicle availability, and pending activities) based on the approved monthly and annual budget. - Manage maintenance indicators (maintainability, reliability, fuel efficiency, fleet condition index, and maintenance cost per kilometer). - Ensure that daily, monthly, quarterly, and annual management reports are prepared and delivered to the Maintenance Department and General Management. - Adjust the maintenance plan according to the fleet’s state and age. - Manage compliance with contractual commitments with Metro Cali S.A. and other entities. - Configure, administer, and manage the maintenance software used by the company. - Verify and control information from the support platforms for the Maintenance area. - Verify and evaluate daily the information provided by the lubrication and fuel engineer on the fleet’s mileage and consumption, and the results of oil sample analyses, adjusting the maintenance system’s parametrization. - Track and control information on non-compliances reported by Metro Cali S.A. vs. fines and maintenance indicators. - Track and control the response to PQRS and OTRS by Metro Cali, which are related to the Maintenance area.\nMaintenance Controller @ Grupo Integrado de Transporte Masivo S.A. (_Jan 2024 - Jul 2024)\n- Develop, control, and track the annual maintenance budget, performing monthly reconciliations with the finance and procurement areas. - Model maintenance costs over the life of the fleet and the concession contract with the Managing Entity. - Support the procurement process in evaluating, selecting, and developing suppliers. - Make projections of critical and sensitive spare part consumption to ensure fleet availability. - Conduct failure analysis, lead strategic planning meetings to design action plans for fleet intervention focused on reliability and contractual compliance. - Control and track the mileage and energy and fuel consumption of the fleet. - Generate annual, semi-annual, and monthly maintenance schedules for the fleet. - Control costs and track all activities in the maintenance process. - Track and control information on non-compliances reported by Metro Cali S.A vs. fines and maintenance indicators.\nMaintenance Manager @ Grupo Integrado de Transporte Masivo S.A. (_August 2022 - Jan 2024)\n- Ensure compliance with the clauses of the current concession contract and its respective others that correspond to the Maintenance area for the provision of the public mass passenger transportation service within the integrated mass transportation system of Santiago de Cali of the Managing Entity. - Implement, standardize and improve the management of your process in order to guarantee compliance with the company’s objectives and the Integrated Management System. - Guarantee compliance with contractual commitments with the Managing Entity, guaranteeing the availability and reliability of the fleet as well as its preventive maintenance. - Develop strategies to increase the productivity levels of the process taking into account the associated resources available by the organization. - Coordinate and provide the necessary resources for the management carried out by the maintenance area collaborators. - Guarantee compliance with commitments with the integrated management system defined by the organization and establish improvement plans when necessary. - Develop knowledge management projects within the maintenance area through process automation and productivity improvement, as well as identify training and qualification needs of the collaborators in charge. - Synergistically ensure with the Operations Department the availability and reliability of the fleet. - Establish and supervise the execution of service agreements agreed upon with suppliers associated with the maintenance area, evaluating and reevaluating the management developed by them. - Plan the implementation, creation and development of projects, plans, activities and/or acquisition of new suppliers that aim to improve the Maintenance process.\nLeader of operational services plan and data analysis @ Grupo Integrado de Transporte Masivo S.A. (_February 2019 - July 2022)\n- Plan, propose and implement process improvement projects through the use of descriptive and inferential statistics. - Apply engineering techniques to achieve cost reduction in production management through resource optimization. - Analyze and evaluate the profitability of resources dedicated to production for decision making. - Presentation of reports, analysis and statistics on a regular basis. - Actively participate in the planning and programming of the distribution of kilometers. - Pose and establish process optimization models through the statistical analysis of distribution and programming data. - Schedule route trips in accordance with the designed offer defined in the Operation Services Plan. - Adjust opening and closing trips that guarantee service coverage to the user up to the times defined in the designed offer. - Determine necessary fleet by type of vehicle according to the designed service offer. - Prepare information to export data to the control center, vehicles and dispatches with part of the fleet operation support system. - Generate preliminary reports, input for optimizing operator shifts.\nProduction Engineer @ Grupo Integrado de Transporte Masivo S.A. (_March 2015 - February 2019)\n- Planning, control and administration of the vehicle fleet. - Programming of yard operators for different activities related to the production area. - Responsible for supervising and controlling operators and technicians, track inspectors and operation controllers. - Coordinate and evaluate operation processes in other yards. Analyze causes of non-compliance with company objectives. - Monitoring and control of corrective and preventive maintenance times.\n\n\n\nDevelopment and implementation of a methodology for detecting atypical trips through the use of control charts for transportation times in the city of Cali.\nCreation and administration of a linear programming model in R language to optimize the distribution of kilometers in service, guaranteeing the expected income and minimizing the cost per empty kilometers and the number of operator-hours."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "What’s inside?",
    "section": "",
    "text": "Want to learn how to use linear programming to optimize your processes and improve your results? Are you interested in learning about the benefits of using R and BI languages for data analysis? Do you want to know how statistics can help you make better decisions in your business? If the answer is yes, this blog is for you.\nIn this blog, I’ll teach you everything you need to know about statistics, data, linear programming, R and BI languages, and process improvement. I’ll show you how to apply these tools and techniques in real-world and practical cases, so you can solve complex problems, reduce costs, increase profits, improve quality and customer satisfaction.\nStatistics is the science of collecting, organizing, analyzing, and interpreting numerical data to extract conclusions and make inferences about a population or phenomenon of interest. Statistics is fundamental for designing experiments, testing hypotheses, estimating parameters, predicting trends, etc.\nLinear programming is a mathematical technique used to optimize the performance or efficiency of a system. It’s based on the idea of maximizing or minimizing a linear function subject to a set of linear constraints. In other words, it’s about finding the best way to assign limited resources to achieve a specific goal.\nR and BI languages are two of the most popular and powerful for data analysis. R is a programming language and software environment that allows you to perform all types of statistical operations, graphics, and modeling. BI (Business Intelligence) is a set of tools and methodologies that enable you to transform data into useful and relevant information for decision-making.\nProcess improvement is a management strategy that aims to increase the effectiveness and efficiency of an organization’s processes by identifying, analyzing, measuring, controlling, and continuously improving them. Process improvement is based on the use of methodologies, tools, and techniques such as the PDCA cycle, Ishikawa diagram, Pareto analysis, Six Sigma, Lean, etc.\nIf you want to learn more about these topics and see how you can apply them to your business, I invite you to keep reading this blog and subscribe to my newsletter (coming soon), where I’ll send you exclusive content, tips, resources, and special offers. You can also leave a comment, question, or suggestion, and I’ll be happy to respond. Thank you for your attention, and see you soon.”"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Cristian Chiquito Valencia",
    "section": "",
    "text": "Logistics, Specialist | Universidad del Valle (September 2019)\nIndustrial Engineer, B.S. | Universidad Icesi (February 2015)\n\n\n\nMaintenance Planner @ Grupo Integrado de Transporte Masivo S.A. (_Jul 2024 - Sep 2024)\n- Propose to the Maintenance Department improvement, recovery, and maintenance projects for the fleet, with technical information by component and system of the buses. - Plan maintenance for the fleet according to the established wear strategy, operational standards, considering the criticality of equipment, fleet age, and manufacturer manuals. - Generate monthly and annual budget information for the Maintenance area based on the maintenance plan and kilometer execution within the information system. - Plan resources required for the maintenance plan for the fleet (spare parts, labor, tools, vehicle availability, and pending activities) based on the approved monthly and annual budget. - Manage maintenance indicators (maintainability, reliability, fuel efficiency, fleet condition index, and maintenance cost per kilometer). - Ensure that daily, monthly, quarterly, and annual management reports are prepared and delivered to the Maintenance Department and General Management. - Adjust the maintenance plan according to the fleet’s state and age. - Manage compliance with contractual commitments with Metro Cali S.A. and other entities. - Configure, administer, and manage the maintenance software used by the company. - Verify and control information from the support platforms for the Maintenance area. - Verify and evaluate daily the information provided by the lubrication and fuel engineer on the fleet’s mileage and consumption, and the results of oil sample analyses, adjusting the maintenance system’s parametrization. - Track and control information on non-compliances reported by Metro Cali S.A. vs. fines and maintenance indicators. - Track and control the response to PQRS and OTRS by Metro Cali, which are related to the Maintenance area.\nMaintenance Controller @ Grupo Integrado de Transporte Masivo S.A. (_Jan 2024 - Jul 2024)\n- Develop, control, and track the annual maintenance budget, performing monthly reconciliations with the finance and procurement areas. - Model maintenance costs over the life of the fleet and the concession contract with the Managing Entity. - Support the procurement process in evaluating, selecting, and developing suppliers. - Make projections of critical and sensitive spare part consumption to ensure fleet availability. - Conduct failure analysis, lead strategic planning meetings to design action plans for fleet intervention focused on reliability and contractual compliance. - Control and track the mileage and energy and fuel consumption of the fleet. - Generate annual, semi-annual, and monthly maintenance schedules for the fleet. - Control costs and track all activities in the maintenance process. - Track and control information on non-compliances reported by Metro Cali S.A vs. fines and maintenance indicators.\nMaintenance Manager @ Grupo Integrado de Transporte Masivo S.A. (_August 2022 - Jan 2024)\n- Ensure compliance with the clauses of the current concession contract and its respective others that correspond to the Maintenance area for the provision of the public mass passenger transportation service within the integrated mass transportation system of Santiago de Cali of the Managing Entity. - Implement, standardize and improve the management of your process in order to guarantee compliance with the company’s objectives and the Integrated Management System. - Guarantee compliance with contractual commitments with the Managing Entity, guaranteeing the availability and reliability of the fleet as well as its preventive maintenance. - Develop strategies to increase the productivity levels of the process taking into account the associated resources available by the organization. - Coordinate and provide the necessary resources for the management carried out by the maintenance area collaborators. - Guarantee compliance with commitments with the integrated management system defined by the organization and establish improvement plans when necessary. - Develop knowledge management projects within the maintenance area through process automation and productivity improvement, as well as identify training and qualification needs of the collaborators in charge. - Synergistically ensure with the Operations Department the availability and reliability of the fleet. - Establish and supervise the execution of service agreements agreed upon with suppliers associated with the maintenance area, evaluating and reevaluating the management developed by them. - Plan the implementation, creation and development of projects, plans, activities and/or acquisition of new suppliers that aim to improve the Maintenance process.\nLeader of operational services plan and data analysis @ Grupo Integrado de Transporte Masivo S.A. (_February 2019 - July 2022)\n- Plan, propose and implement process improvement projects through the use of descriptive and inferential statistics. - Apply engineering techniques to achieve cost reduction in production management through resource optimization. - Analyze and evaluate the profitability of resources dedicated to production for decision making. - Presentation of reports, analysis and statistics on a regular basis. - Actively participate in the planning and programming of the distribution of kilometers. - Pose and establish process optimization models through the statistical analysis of distribution and programming data. - Schedule route trips in accordance with the designed offer defined in the Operation Services Plan. - Adjust opening and closing trips that guarantee service coverage to the user up to the times defined in the designed offer. - Determine necessary fleet by type of vehicle according to the designed service offer. - Prepare information to export data to the control center, vehicles and dispatches with part of the fleet operation support system. - Generate preliminary reports, input for optimizing operator shifts.\nProduction Engineer @ Grupo Integrado de Transporte Masivo S.A. (_March 2015 - February 2019)\n- Planning, control and administration of the vehicle fleet. - Programming of yard operators for different activities related to the production area. - Responsible for supervising and controlling operators and technicians, track inspectors and operation controllers. - Coordinate and evaluate operation processes in other yards. Analyze causes of non-compliance with company objectives. - Monitoring and control of corrective and preventive maintenance times.\n\n\n\nDevelopment and implementation of a methodology for detecting atypical trips through the use of control charts for transportation times in the city of Cali.\nCreation and administration of a linear programming model in R language to optimize the distribution of kilometers in service, guaranteeing the expected income and minimizing the cost per empty kilometers and the number of operator-hours."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Here are the branches of creations."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog",
    "section": "",
    "text": "Retomando labores\n\n\n\n\n\n\nCristian Chiquito Valencia\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducción a Git\n\n\n\nGit\n\n\n\nFundamental para Data Science\n\n\n\nCristian Chiquito Valencia\n\n\nNov 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducción a Github\n\n\n\nGithub\n\n\n\nColaboración para Data Science\n\n\n\nCristian Chiquito Valencia\n\n\nNov 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRetomando labores\n\n\n\nGit\n\n\n\nClonando repositorio a local\n\n\n\nCristian Chiquito Valencia\n\n\nNov 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGreedy Randomized Adaptative Search\n\n\n\nR\n\n\noptimización\n\n\n\nBúsqueda Adaptativa Aleatoria y Codiciosa\n\n\n\nCristian Chiquito Valencia\n\n\nDec 8, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable Neighborhood Search\n\n\n\nR\n\n\noptimización\n\n\n\nBúsqueda de Vencindario Variable\n\n\n\nCristian Chiquito Valencia\n\n\nDec 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGuided Local serach\n\n\n\nR\n\n\noptimización\n\n\n\nBúsqueda Local Guiada\n\n\n\nCristian Chiquito Valencia\n\n\nNov 19, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIterated Local serach\n\n\n\nR\n\n\noptimización\n\n\n\nBúsqueda Local Iterada\n\n\n\nCristian Chiquito Valencia\n\n\nNov 18, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRandom Search\n\n\n\nR\n\n\noptimización\n\n\n\nBúsqueda aleatoria\n\n\n\nCristian Chiquito Valencia\n\n\nNov 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStochastic Hill Climbing\n\n\n\nR\n\n\noptimización\n\n\n\nEscalada estocástica\n\n\n\nCristian Chiquito Valencia\n\n\nNov 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdaptative Random Search\n\n\n\nR\n\n\noptimización\n\n\n\nBúsqueda aleatoria adaptativa\n\n\n\nCristian Chiquito Valencia\n\n\nNov 13, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n¿Cómo crear un post?\n\n\n\nQuarto\n\n\nR\n\n\n\nParece ser una buena manera de conservar un buen flujo de trabajo\n\n\n\nCristian Chiquito Valencia\n\n\nNov 12, 2023\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-11-12-crear_un_post/index.html",
    "href": "posts/2023-11-12-crear_un_post/index.html",
    "title": "¿Cómo crear un post?",
    "section": "",
    "text": "Ahora que ya tienes tu página configurada, puedes empezar a llenarla con entradas de blog. Repite los siguientes pasos cada vez que desees añadir un nuevo post.\nCrea un subdirectorio dentro de tu directorio posts/: Para mantenerme organizado, suelo nombrar el mío YYYY-MM-DD-describe_post. Este nombre de carpeta también se convertirá en la parte identificativa única de una dirección web (normalmente al final de la URL) de tu post publicado.\nDentro de tu nuevo subdirectorio, crea un archivo index.qmd. El nombre es importante. Debe llamarse index.qmd. La ruta del archivo debe ser similar a la siguiente: …/posts/2023-11-12-crear_un_post/index.qmd. Este archivo es la entrada de tu blog. Escribe todo el contenido aquí. Configure su entrada de blog: Puedes añadir diferentes opciones a la sección YAML de index.qmd.\n\nrunif(1,0,100)\n\n[1] 1.481772\n\n\n\n\n\nCitationBibTeX citation:@online{chiquito_valencia2023,\n  author = {Chiquito Valencia, Cristian},\n  title = {¿Cómo Crear Un Post?},\n  date = {2023-11-12},\n  url = {https://cchiquitovalencia.github.io/posts/2023-11-12-crear_un_post/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nChiquito Valencia, Cristian. 2023. “¿Cómo Crear Un Post?”\nNovember 12, 2023. https://cchiquitovalencia.github.io/posts/2023-11-12-crear_un_post/."
  },
  {
    "objectID": "posts/2023-11-13-random_search_algorithm/index.html",
    "href": "posts/2023-11-13-random_search_algorithm/index.html",
    "title": "Random Search",
    "section": "",
    "text": "Random Search pertenece a los campos de la Optimización Estocástica y la Optimización Global. Es un método de búsqueda directa, no requiere derivadas para buscar en un dominio continuo. Este enfoque está relacionado con técnicas que proporcionan pequeñas mejoras, como la Directed Random Search y la Adaptative Random Search."
  },
  {
    "objectID": "posts/2023-11-13-random_search_algorithm/index.html#taxonomía",
    "href": "posts/2023-11-13-random_search_algorithm/index.html#taxonomía",
    "title": "Random Search",
    "section": "",
    "text": "Random Search pertenece a los campos de la Optimización Estocástica y la Optimización Global. Es un método de búsqueda directa, no requiere derivadas para buscar en un dominio continuo. Este enfoque está relacionado con técnicas que proporcionan pequeñas mejoras, como la Directed Random Search y la Adaptative Random Search."
  },
  {
    "objectID": "posts/2023-11-13-random_search_algorithm/index.html#estrategia",
    "href": "posts/2023-11-13-random_search_algorithm/index.html#estrategia",
    "title": "Random Search",
    "section": "Estrategia",
    "text": "Estrategia\nLa estrategia de Random Search consiste en muestrear soluciones de todo el espacio de búsqueda utilizando una distribución de probabilidad uniforme. Cada muestra futura es independiente de las anteriores."
  },
  {
    "objectID": "posts/2023-11-13-random_search_algorithm/index.html#procedimiento",
    "href": "posts/2023-11-13-random_search_algorithm/index.html#procedimiento",
    "title": "Random Search",
    "section": "Procedimiento",
    "text": "Procedimiento\n\n\n\nPseudocódigo Random Search"
  },
  {
    "objectID": "posts/2023-11-13-random_search_algorithm/index.html#heurística",
    "href": "posts/2023-11-13-random_search_algorithm/index.html#heurística",
    "title": "Random Search",
    "section": "Heurística",
    "text": "Heurística\nRandom Search es minimalista en el sentido de que sólo requiere una rutina de construcción de soluciones candidatas y una rutina de evaluación de soluciones candidatas, ambas pueden calibrarse con el enfoque.\nEn el peor de los casos, el rendimiento de Random Search para localizar el óptimo es peor que una Enumeración del dominio de búsqueda, dado que Random Search no tiene memoria y puede remuestrear a ciegas.\nRandom Search puede devolver una aproximación razonable de la solución óptima en un tiempo razonable con problemas de baja dimensionalidad, aunque el enfoque no se escala bien con tamaño del problema (como el número de dimensiones).\nHay que tener cuidado con algunos dominios de problemas para garantizar que la construcción aleatoria de soluciones candidatas no esté sesgada.\nLos resultados de una Random Search pueden utilizarse para sembrar otra técnica de búsqueda, como una técnica de búsqueda local (como el algoritmo Hill Climbing) que se puede utilizar para localizar la mejor solución en la vecindad de la “buena” solución candidata."
  },
  {
    "objectID": "posts/2023-11-13-random_search_algorithm/index.html#código",
    "href": "posts/2023-11-13-random_search_algorithm/index.html#código",
    "title": "Random Search",
    "section": "Código",
    "text": "Código\nEl problema de ejemplo es un caso de optimización continua que busca:\n\\(min f(x)\\) donde \\(f = ∑_{i=1}^n X_i^2\\), \\(-5.0&lt;=x_i&lt;=5.0\\) y \\(n=2\\).\nLa solución óptima para esta función es \\((v_0,…,v_{n-1})=0.0\\)\n\n# Definir la función objetivo\nobjective_function &lt;- function(vector) {\n    return(sum(vector^2))\n}\n\n# Generar un vector aleatorio\nrandom_vector &lt;- function(minmax) {\n    return(runif(length(minmax), min = minmax[,1], max = minmax[,2]))\n}\n\n# Realizar la bósqueda aleatoria\nsearch &lt;- function(search_space, max_iter) {\n    best &lt;- NULL\n    costs &lt;- c()  # Vector para almacenar los costos\n    for (iter in 1:max_iter) {\n        candidate &lt;- list()\n        candidate$vector &lt;- random_vector(search_space)\n        candidate$cost &lt;- objective_function(candidate$vector)\n        costs &lt;- c(costs, candidate$cost)  # Almacenar el costo de la iteraciÃ³n actual\n        if (is.null(best) || candidate$cost &lt; best$cost) {\n            best &lt;- candidate\n        }\n    }\n    return(list(best = best, costs = costs))  # Devolver el mejor resultado y los costos\n}\n\n# Configuración del problema\nproblem_size &lt;- 2\nsearch_space &lt;- matrix(c(-5, 5), nrow = problem_size, ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iter &lt;- 1000\n\n# Ejecutar el algoritmo\nresult &lt;- search(search_space, max_iter)\nbest &lt;- result$best\ncosts &lt;- result$costs\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\nlibrary(ggplot2)\n\n# Crear un dataframe con los costos\ndf &lt;- data.frame(\n    Iteration = 1:length(costs),\n    Cost = costs\n)\n\n# Crear modificaciones al plot\ncrear_tema &lt;- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(df, aes(x = Iteration, y = Cost)) +\n    geom_line(colour = \"#4d6080\", size = 1) +\n    labs(\n        title = \"Progreso de la función objetivo\",\n        x = \"Iteración\",\n        y = \"Costo\"\n    ) +\n    crear_tema()\n\n\n\n\n\n\n\n\nLa solución óptima es entonces:\n\nresult$best$vector\n\n[1] -0.22629315  0.16421375  0.04845694  0.29233937"
  },
  {
    "objectID": "posts/2023-11-13-adaptative_random_search/index.html",
    "href": "posts/2023-11-13-adaptative_random_search/index.html",
    "title": "Adaptative Random Search",
    "section": "",
    "text": "El algoritmo Adaptative Random Search pertenece al conjunto general de enfoques conocidos como Optimización Estocástica y Optimización Global.\nEs un método de búsqueda directa, en el sentido de que no requiere derivadas para para navegar por el espacio de búsqueda. Adaptative Random Search es una extensión de los algoritmos Random Search."
  },
  {
    "objectID": "posts/2023-11-13-adaptative_random_search/index.html#taxonomía",
    "href": "posts/2023-11-13-adaptative_random_search/index.html#taxonomía",
    "title": "Adaptative Random Search",
    "section": "",
    "text": "El algoritmo Adaptative Random Search pertenece al conjunto general de enfoques conocidos como Optimización Estocástica y Optimización Global.\nEs un método de búsqueda directa, en el sentido de que no requiere derivadas para para navegar por el espacio de búsqueda. Adaptative Random Search es una extensión de los algoritmos Random Search."
  },
  {
    "objectID": "posts/2023-11-13-adaptative_random_search/index.html#estrategia",
    "href": "posts/2023-11-13-adaptative_random_search/index.html#estrategia",
    "title": "Adaptative Random Search",
    "section": "Estrategia",
    "text": "Estrategia\nEl algoritmo Adaptative Random Search fue diseñado para abordar las limitaciones del tamaño de paso fijo en el algoritmo de Localized Random Search.\nLa estrategia de la Adaptative Random Search consiste en realizar paso óptimo necesario para alcanzar el óptimo global en el espacio de búsqueda. Esto se consigue probando y adoptando tamaños de paso menores o mayores sólo si mejoran el rendimiento de la búsqueda.\nLa estrategia del algoritmo Adaptive Step Size Random Search (la técnica específica revisada) consiste en probar un paso mayor en cada iteración y adoptarlo si mejora el resultado. Los pasos muy grandes se prueban de la misma manera, aunque con una frecuencia mucho menor. Esta estrategia de preferir movimientos grandes tiene por objeto permitir que la técnica escape a los óptimos locales. Los pasos más pequeños se adoptan si no se produce ninguna mejora durante un periodo prolongado."
  },
  {
    "objectID": "posts/2023-11-13-adaptative_random_search/index.html#procedimiento",
    "href": "posts/2023-11-13-adaptative_random_search/index.html#procedimiento",
    "title": "Adaptative Random Search",
    "section": "Procedimiento",
    "text": "Procedimiento\n\n\n\nPseudocódigo Adaptative Random Search"
  },
  {
    "objectID": "posts/2023-11-13-adaptative_random_search/index.html#heurística",
    "href": "posts/2023-11-13-adaptative_random_search/index.html#heurística",
    "title": "Adaptative Random Search",
    "section": "Heurística",
    "text": "Heurística\nAdaptative Random Search fue diseñado para dominios de problemas de optimización de funciones continuas.\nLos candidatos con igual costo deben considerarse mejoras para permitir que el algoritmo progrese a través de mesetas en la superficie de respuesta.\nAdaptative Random Search puede adaptar la dirección de búsqueda además del tamaño del paso.\nEl tamaño del paso puede adaptarse para todos los parámetros o para cada parámetro individualmente."
  },
  {
    "objectID": "posts/2023-11-13-adaptative_random_search/index.html#código",
    "href": "posts/2023-11-13-adaptative_random_search/index.html#código",
    "title": "Adaptative Random Search",
    "section": "Código",
    "text": "Código\nEn el ejemplo, el algoritmo se ejecuta durante un número fijo de iteraciones y devuelve la mejor solución candidata descubierta. El problema del ejemplo es un caso de optimización de una función continua que busca\n\\(min f(x)\\) donde \\(f = ∑_{i=1}^n X_i^2\\), \\(-5.0&lt;=x_i&lt;=5.0\\) y \\(n=2\\).\nLa solución óptima para esta función es \\((v_0,...,v_{n-1})=0.0\\)\n\n# Definir la función objetivo\nobjective_function &lt;- function(vector) {\n    return(sum(vector^2))\n}\n\n# Generar un número aleatorio en el intervalo [min, max]\nrand_in_bounds &lt;- function(min, max) {\n    return(min + ((max-min) * runif(1)))\n}\n\n# Generar un vector aleatorio en el espacio de búsqueda\nrandom_vector &lt;- function(minmax) {\n    #minmax &lt;- matrix(bounds,nrow = problem_size, ncol = problem_size, byrow = FALSE)\n    return(runif(length(minmax), min = minmax[,1], max = minmax[,2]))\n}\n\n# Dar un paso en una dirección aleatoria\ntake_step &lt;- function(minmax, current, step_size) {\n    position &lt;- numeric(length(current))\n    for (i in 1:(length(current)/problem_size)) {\n        min &lt;- max(minmax[i,1], current[i]-step_size)\n        max &lt;- min(minmax[i,2], current[i]+step_size)\n        position[i] &lt;- rand_in_bounds(min, max)\n    }\n    return(position)\n}\n\n# Dar un paso grande en una dirección aleatoria\nlarge_step_size &lt;- function(iter, step_size, s_factor, l_factor, iter_mult) {\n    if (iter &gt; 0 && iter %% iter_mult == 0) {\n        return(step_size * l_factor)\n    } else {\n        return(step_size * s_factor)\n    }\n}\n\n# Dar un paso y un gran paso en direcciones aleatorias\ntake_steps &lt;- function(bounds, current, step_size, big_stepsize) {\n    step &lt;- list()\n    big_step &lt;- list()\n    step$vector &lt;- take_step(bounds, current$vector, step_size)\n    step$cost &lt;- objective_function(step$vector)\n    big_step$vector &lt;- take_step(bounds, current$vector, big_stepsize)\n    big_step$cost &lt;- objective_function(big_step$vector)\n    return(list(step, big_step))\n}\n\n# Inicializar un dataframe para almacenar los resultados\nresults &lt;- data.frame(iteration = integer(), cost = numeric())\n\n# Realizar la búsqueda aleatoria adaptativa\nsearch &lt;- function(max_iter, bounds, init_factor, s_factor, l_factor, iter_mult, max_no_impr) {\n    step_size &lt;- (bounds[1,2]-bounds[1,1]) * init_factor\n    current &lt;- list()\n    current$vector &lt;- random_vector(bounds)\n    current$cost &lt;- objective_function(current$vector)\n    count &lt;- 0\n    for (iter in 1:max_iter) {\n        big_stepsize &lt;- large_step_size(iter, step_size, s_factor, l_factor, iter_mult)\n        steps &lt;- take_steps(bounds, current, step_size, big_stepsize)\n        if (steps[[1]]$cost &lt;= current$cost || steps[[2]]$cost &lt;= current$cost) {\n            if (steps[[2]]$cost &lt;= steps[[1]]$cost) {\n                step_size &lt;- big_stepsize\n                current &lt;- steps[[2]]\n            } else {\n                current &lt;- steps[[1]]\n            }\n            count &lt;- 0\n        } else {\n            count &lt;- count + 1\n            if (count &gt;= max_no_impr) {\n                step_size &lt;- step_size / s_factor\n                count &lt;- 0\n            }\n        }\n        # Almacenar los resultados en el dataframe\n        results &lt;&lt;- rbind(results, data.frame(iteration = iter, cost = current$cost))\n    }\n    return(current)\n}\n\n# Configuración del problema\nproblem_size &lt;- 2\nbounds &lt;- matrix(c(-5, 5), nrow = problem_size, ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iter &lt;- 100\ninit_factor &lt;- 0.05\ns_factor &lt;- 1.3\nl_factor &lt;- 3.0\niter_mult &lt;- 10\nmax_no_impr &lt;- 30\n\n# Ejecutar el algoritmo\nbest &lt;- search(max_iter, bounds, init_factor, s_factor, l_factor, iter_mult, max_no_impr)\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\nlibrary(ggplot2)\n\n# Crear modificaciones al plot\ncrear_tema &lt;- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(results, aes(x = iteration, y = cost)) +\n    geom_line() +\n    labs(title = \"Progreso de la función objetivo\", \n         x = \"Iteración\", y = \"Costo\")+\n    crear_tema()\n\n\n\n\n\n\n\n\nLa solución óptima es entonces:\n\nbest$vector\n\n[1]  0.03174900 -0.06707623  0.00000000  0.00000000"
  },
  {
    "objectID": "posts/2023-11-13-stochastic_hill_climbing/index.html",
    "href": "posts/2023-11-13-stochastic_hill_climbing/index.html",
    "title": "Stochastic Hill Climbing",
    "section": "",
    "text": "El algoritmo Stochastic Hill Climbing es un algoritmo de Optimización Estocástica y es un algoritmo de Optimización Local (a diferencia de la Optimización Global). Es una técnica de búsqueda directa, ya que no requiere derivadas del espacio de búsqueda. Stochastic Hill Climbing es una extensión de los algoritmos deterministas como el Simple Hill Climbing (primer mejor vecino), Steepest-Ascent Hill Climbing (mejor vecino), y un padre de enfoques como Parallel Hill Climbing y Random-Restart Hill Climbing."
  },
  {
    "objectID": "posts/2023-11-13-stochastic_hill_climbing/index.html#taxonomía",
    "href": "posts/2023-11-13-stochastic_hill_climbing/index.html#taxonomía",
    "title": "Stochastic Hill Climbing",
    "section": "",
    "text": "El algoritmo Stochastic Hill Climbing es un algoritmo de Optimización Estocástica y es un algoritmo de Optimización Local (a diferencia de la Optimización Global). Es una técnica de búsqueda directa, ya que no requiere derivadas del espacio de búsqueda. Stochastic Hill Climbing es una extensión de los algoritmos deterministas como el Simple Hill Climbing (primer mejor vecino), Steepest-Ascent Hill Climbing (mejor vecino), y un padre de enfoques como Parallel Hill Climbing y Random-Restart Hill Climbing."
  },
  {
    "objectID": "posts/2023-11-13-stochastic_hill_climbing/index.html#estrategia",
    "href": "posts/2023-11-13-stochastic_hill_climbing/index.html#estrategia",
    "title": "Stochastic Hill Climbing",
    "section": "Estrategia",
    "text": "Estrategia\nLa estrategia del Stochastic Hill Climbing consiste en iterar el proceso de selección aleatoria de un vecino para una solución candidata y aceptarla sólo si da lugar a una mejora. La estrategia se propuso para hacer frente a las limitaciones de las técnicas de ascenso determinista que se atascaban en óptimos locales debido a su avariciosa aceptación de movimientos vecinos."
  },
  {
    "objectID": "posts/2023-11-13-stochastic_hill_climbing/index.html#procedimiento",
    "href": "posts/2023-11-13-stochastic_hill_climbing/index.html#procedimiento",
    "title": "Stochastic Hill Climbing",
    "section": "Procedimiento",
    "text": "Procedimiento\n\n\n\nPseudocódigo Stochastic Hill Climbing"
  },
  {
    "objectID": "posts/2023-11-13-stochastic_hill_climbing/index.html#heurística",
    "href": "posts/2023-11-13-stochastic_hill_climbing/index.html#heurística",
    "title": "Stochastic Hill Climbing",
    "section": "Heurística",
    "text": "Heurística\nStochastic Hill Climbing fue diseñado para ser utilizado en dominios discretos con vecinos explícitos, como la optimización combinatoria (en comparación con la optimización de funciones continuas).\nLa estrategia del algoritmo puede aplicarse a dominios continuos haciendo uso de un tamaño de paso para definir los vecinos de la solución candidata (como la Localized Random Search y la Fixed Step-Size Random Search).\nStochastic Hill Climbing es una técnica de búsqueda local (en comparación a la búsqueda global) y puede utilizarse para refinar un resultado tras la ejecución de un algoritmo de búsqueda global.\nAunque la técnica utiliza un proceso estocástico, aún puede atascarse en óptimos locales.\nLos vecinos con mejor o igual costo deben ser aceptados, lo que permite a la técnica navegar a través de mesetas en la superficie de respuesta.\nEl algoritmo puede reiniciarse y repetirse una serie de veces veces después de que converja para obtener un resultado mejorado (lo que se denomina Multiple Restart Hill Climbing).\nEl procedimiento puede aplicarse a varias soluciones candidatas simultáneamente, lo que permite ejecutar varios algoritmos al mismo tiempo (llamado Parallel Hill Climbing)."
  },
  {
    "objectID": "posts/2023-11-13-stochastic_hill_climbing/index.html#código",
    "href": "posts/2023-11-13-stochastic_hill_climbing/index.html#código",
    "title": "Stochastic Hill Climbing",
    "section": "Código",
    "text": "Código\nEl algoritmo se ejecuta durante un número fijo de iteraciones y se aplica a un problema de optimización de cadena binaria denominado ‘One Max’. El objetivo de este problema de maximización es preparar una cadena con todos los bits ‘1’, donde la función de costo sólo informa del número de bits en una cadena dada.\n\n# Función para calcular la suma de los unos en un vector\nonemax &lt;- function(vector) {\n    return(sum(vector == \"1\"))\n}\n\n# Función para generar una cadena de bits aleatorios\nrandom_bitstring &lt;- function(num_bits) {\n    return(sample(c(\"0\", \"1\"), num_bits, replace = TRUE))\n}\n\n# Función para generar un vecino aleatorio cambiando un bit\nrandom_neighbor &lt;- function(bitstring) {\n    mutant &lt;- bitstring\n    pos &lt;- sample(seq_along(bitstring), 1)\n    mutant[pos] &lt;- ifelse(mutant[pos] == \"1\", \"0\", \"1\")\n    return(mutant)\n}\n\n# Función de búsqueda principal\nsearch &lt;- function(max_iterations, num_bits) {\n    # Inicializar el candidato con un vector aleatorio y calcular su costo\n    candidate &lt;- list()\n    candidate$vector &lt;- random_bitstring(num_bits)\n    candidate$cost &lt;- onemax(candidate$vector)\n    costs &lt;- c()  # Vector para almacenar los costos\n    # Iterar hasta el número máximo de iteraciones\n    for (iter in seq_len(max_iterations)) {\n        # Generar un vecino y calcular su costo\n        neighbor &lt;- list()\n        neighbor$vector &lt;- random_neighbor(candidate$vector)\n        neighbor$cost &lt;- onemax(neighbor$vector)\n        costs &lt;- c(costs, candidate$cost)  # Almacenar el costo de la iteración actual\n        # Si el vecino es mejor o igual, actualizar el candidato\n        if (neighbor$cost &gt;= candidate$cost) {\n            candidate &lt;- neighbor\n        }\n        # Si se encuentra la solución óptima, terminar\n        if (candidate$cost == num_bits) {\n            break\n        }\n    }\n    # Devolver el mejor candidato encontrado y los costos\n    return(list(best = candidate, costs = costs))\n}\n\n# Configuración del problema\nnum_bits &lt;- 64\n\n# Configuración del algoritmo\nmax_iterations &lt;- 1000\n\n# Ejecutar el algoritmo\nresult &lt;- search(max_iterations, num_bits)\nbest &lt;- result$best\ncosts &lt;- result$costs\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\nlibrary(ggplot2)\n# Crear un gráfico del progreso de la función objetivo\ndf &lt;- data.frame(\n  Iteration = 1:length(costs),\n  Cost = costs\n)\n\n# Crear modificaciones al plot\ncrear_tema &lt;- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(df, aes(x = Iteration, y = Cost)) +\n  geom_line(colour = \"steelblue\", size = 1) +\n  labs(\n    title = \"Progreso de la función objetivo\",\n    subtitle = \"Visualización del costo a lo largo de las iteraciones\",\n    x = \"Iteración\",\n    y = \"Costo\"\n  ) +\n  crear_tema()\n\n\n\n\n\n\n\n\nLa solución óptima es entonces:\n\nresult$best$vector\n\n [1] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\n[20] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\n[39] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\n[58] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\""
  },
  {
    "objectID": "posts/2023-11-18-iterated_local_search/index.html",
    "href": "posts/2023-11-18-iterated_local_search/index.html",
    "title": "Iterated Local serach",
    "section": "",
    "text": "Iterated Local Search es una Metaheurística y una técnica de Optimización Global. Es una extensión de Multi-Restar Search y puede considerarse la base de muchos enfoques de búsqueda en dos fases, como el procedimiento de Greedy Randomized Adaptive Search Procedure y Variable Neighborhood Search."
  },
  {
    "objectID": "posts/2023-11-18-iterated_local_search/index.html#taxonomía",
    "href": "posts/2023-11-18-iterated_local_search/index.html#taxonomía",
    "title": "Iterated Local serach",
    "section": "",
    "text": "Iterated Local Search es una Metaheurística y una técnica de Optimización Global. Es una extensión de Multi-Restar Search y puede considerarse la base de muchos enfoques de búsqueda en dos fases, como el procedimiento de Greedy Randomized Adaptive Search Procedure y Variable Neighborhood Search."
  },
  {
    "objectID": "posts/2023-11-18-iterated_local_search/index.html#estrategia",
    "href": "posts/2023-11-18-iterated_local_search/index.html#estrategia",
    "title": "Iterated Local serach",
    "section": "Estrategia",
    "text": "Estrategia\nEl objetivo de Iterated Local Search es mejorar la Multi-Restar Search mediante el muestreo en la vecindad más amplia de soluciones candidatas y el uso de una técnica de Local Search para reﬁnar las soluciones a sus óptimos locales. Iterated Local Search explora una secuencia de soluciones creadas como perturbaciones de la mejor solución actual, cuyo resultado se reﬁna mediante una heurística integrada."
  },
  {
    "objectID": "posts/2023-11-18-iterated_local_search/index.html#procedimiento",
    "href": "posts/2023-11-18-iterated_local_search/index.html#procedimiento",
    "title": "Iterated Local serach",
    "section": "Procedimiento",
    "text": "Procedimiento\n\n\n\nPseudocódigo Iterated Local Search"
  },
  {
    "objectID": "posts/2023-11-18-iterated_local_search/index.html#heurística",
    "href": "posts/2023-11-18-iterated_local_search/index.html#heurística",
    "title": "Iterated Local serach",
    "section": "Heurística",
    "text": "Heurística\nIterated Local Search se diseñó para, y se ha aplicado, predominantemente a dominios discretos, como los problemas de optimización combinatoria.\nLa perturbación de la mejor solución actual debe estar en un vecindario más allá del alcance de la heurística incorporada y no debe deshacerse fácilmente.\nLas perturbaciones demasiado pequeñas hacen que el algoritmo sea demasiado codicioso, mientras que las perturbaciones demasiado grandes hacen que el algoritmo sea demasiado estocástico.\nLa heurística incrustada suele ser una técnica de búsqueda local específica del problema.\nEl punto de partida de la búsqueda puede ser una solución candidata construida aleatoriamente o mediante una heurística específica del problema (como el vecino más próximo).\nLas perturbaciones pueden hacerse de forma determinista, aunque las más comunes son las estocásticas y probabilísticas (adaptativas basadas en el historial).\nEl procedimiento puede almacenar tanto o tan poco historial como sea necesario para utilizarlo durante la perturbación y los criterios de aceptación. La ausencia de historial representa un paseo aleatorio en un vecindario más amplio de la mejor solución y es la aplicación más común del enfoque.\nEl criterio de aceptación más simple y común es una mejora en el costo de las soluciones candidatas construidas."
  },
  {
    "objectID": "posts/2023-11-18-iterated_local_search/index.html#código",
    "href": "posts/2023-11-18-iterated_local_search/index.html#código",
    "title": "Iterated Local serach",
    "section": "Código",
    "text": "Código\nEl algoritmo se aplica a la instancia Berlin52 del Traveling Saleman Problem (TSP), tomada de la TSPLIB. El problema busca una permutación del orden de visita de las ciudades (llamada recorrido) que minimice la distancia total recorrida. La distancia óptima del recorrido para el caso Berlín52 es de 7.542 unidades.\nIterated Local Search se ejecuta durante un número fijo de iteraciones. La implementación se basa en un algoritmo común conﬁguración para el TSP, donde un 'double-bridge move' (4-opt) se utiliza como la técnica de perturbación, y un 2-opt estocástico se utiliza como la heurística de búsqueda local incrustada. El doube-bridge move consiste en dividir una permutación en 4 partes (a,b,c,d) y volver a unirlas en un orden específico y desordenado (a,d,c,b).\n\n# Función para calcular la distancia euclidiana entre dos puntos\neuc_2d &lt;- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Función para calcular el costo de una permutación de ciudades\ncost &lt;- function(permutation, cities) {\n    distance &lt;- 0\n    for (i in seq_along(permutation)) {\n        c1 &lt;- permutation[i]\n        c2 &lt;- if (i == length(permutation)) permutation[1] else permutation[i + 1]\n        distance &lt;- distance + euc_2d(cities[c1, ], cities[c2, ])\n    }\n    return(distance)\n}\n\n# Función para generar una permutación aleatoria de las ciudades\nrandom_permutation &lt;- function(cities) {\n    return(sample(nrow(cities)))\n}\n\n# Función para realizar una operación de dos-opt estocástica en una permutación\nstochastic_two_opt &lt;- function(permutation) {\n    perm &lt;- permutation\n    c1 &lt;- sample(length(perm), 1)\n    exclude &lt;- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 &lt;- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 &lt;- sample(length(perm), 1)\n    }\n    if (c2 &lt; c1) {\n        c1 &lt;- c2\n        c2 &lt;- c1\n    }\n    perm[c1:c2] &lt;- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Función para realizar una búsqueda local en el espacio de las permutaciones\nlocal_search &lt;- function(best, cities, max_no_improv) {\n    count &lt;- 0\n    repeat {\n        candidate &lt;- list()\n        candidate$vector &lt;- stochastic_two_opt(best$vector)\n        candidate$cost &lt;- cost(candidate$vector, cities)\n        if (candidate$cost &lt; best$cost) {\n            count &lt;- 0\n            best &lt;- candidate\n        } else {\n            count &lt;- count + 1\n        }\n        if (count &gt;= max_no_improv) break\n    }\n    return(best)\n}\n\n# Función para realizar un movimiento de doble puente en una permutación\ndouble_bridge_move &lt;- function(perm) {\n    pos1 &lt;- 1 + sample(floor(length(perm) / 4), 1)\n    pos2 &lt;- pos1 + 1 + sample(floor(length(perm) / 4), 1)\n    pos3 &lt;- pos2 + 1 + sample(floor(length(perm) / 4), 1)\n    return(c(perm[1:pos1], perm[(pos3 + 1):length(perm)], perm[(pos2 + 1):pos3], perm[(pos1 + 1):pos2]))\n}\n\n# Función para perturbar la mejor solución encontrada hasta ahora\nperturbation &lt;- function(cities, best) {\n    candidate &lt;- list()\n    candidate$vector &lt;- double_bridge_move(best$vector)\n    candidate$cost &lt;- cost(candidate$vector, cities)\n    return(candidate)\n}\n\n# Función de búsqueda principal\nsearch &lt;- function(cities, max_iterations, max_no_improv) {\n    best &lt;- list()\n    best$vector &lt;- random_permutation(cities)\n    best$cost &lt;- cost(best$vector, cities)\n    best &lt;- local_search(best, cities, max_no_improv)\n    # Creamos un vector para almacenar el costo del mejor vector en cada iteración\n    best_costs &lt;- numeric(max_iterations)\n    for (iter in seq_len(max_iterations)) {\n        candidate &lt;- perturbation(cities, best)\n        candidate &lt;- local_search(candidate, cities, max_no_improv)\n        if (candidate$cost &lt; best$cost) {\n            best &lt;- candidate\n        }\n        # Almacenamos el costo del mejor vector en la iteración actual\n        best_costs[iter] &lt;- best$cost\n        #print(paste(\" &gt; iteration\", iter, \", best=\", best$cost))\n    }\n    return(list(best = best, best_costs = best_costs))\n}\n\n# Configuración del problema\nberlin52 &lt;- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,300,\n                     465,520,585,480,415,835,625,975,580,1215,245,\n                     1320,315,1250,400,660,180,410,250,420,555,575,\n                     665,1150,1160,700,580,685,595,685,610,770,610,\n                     795,645,720,635,760,650,475,960,95,260,875,920,\n                     700,500,555,815,830,485,1170,65,830,610,605,625,\n                     595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iterations &lt;- 100\nmax_no_improv &lt;- 50\n\n# Ejecutar el algoritmo\nresult &lt;- search(berlin52, max_iterations, max_no_improv)\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\n# Crear un gráfico del progreso de la función objetivo\nlibrary(ggplot2)\n\ndf &lt;- data.frame(iteration = 1:max_iterations, cost = result$best_costs)\n\n# Crear modificaciones al plot\ncrear_tema &lt;- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\n\nggplot(df, aes(x = iteration, y = cost)) +\n    geom_line() +\n    labs(title = \"Progreso del costo a lo largo de las iteraciones\", x = \"Iteración\", y = \"Costo\")+\n    crear_tema()\n\n\n\n\n\n\n\n\nLa solución óptima (con las iteraciones establecidas) es entonces:\n\nresult$best$vector\n\n [1] 18 49 32 35 34  1 44 39 40 36 16 23  7  2 42 30 20 50 29 46 48  5 38 15  6\n[26] 24 37 27 11 52 14 13 47 28 26 25  4 12 51 33 10 43  9  8 19 41 45  3 17 21\n[51] 31 22"
  },
  {
    "objectID": "posts/2023-11-19-guided_local_search/index.html",
    "href": "posts/2023-11-19-guided_local_search/index.html",
    "title": "Guided Local serach",
    "section": "",
    "text": "El algoritmo de Guided Local Search es una Metaheurística y un algoritmo de Optimización Global que hace uso de un algoritmo de Local Search embebido. Se trata de una extensión de los algoritmos de búsqueda local como Hill Climbing y es similar en estrategia al algoritmo de Tabu Search y al algoritmo de Iterated Local Search."
  },
  {
    "objectID": "posts/2023-11-19-guided_local_search/index.html#taxonomía",
    "href": "posts/2023-11-19-guided_local_search/index.html#taxonomía",
    "title": "Guided Local serach",
    "section": "",
    "text": "El algoritmo de Guided Local Search es una Metaheurística y un algoritmo de Optimización Global que hace uso de un algoritmo de Local Search embebido. Se trata de una extensión de los algoritmos de búsqueda local como Hill Climbing y es similar en estrategia al algoritmo de Tabu Search y al algoritmo de Iterated Local Search."
  },
  {
    "objectID": "posts/2023-11-19-guided_local_search/index.html#estrategia",
    "href": "posts/2023-11-19-guided_local_search/index.html#estrategia",
    "title": "Guided Local serach",
    "section": "Estrategia",
    "text": "Estrategia\nLa estrategia del algoritmo Guided Local Search consiste en utilizar penalizaciones para animar a una técnica de Local Search a escapar de los óptimos locales y descubrir el óptimo global. Un algoritmo de Local Search se ejecuta hasta que se queda atascado en un óptimo local. Las características de los óptimos locales se evalúan y se penalizan, sus resultados se utilizan en una función de costo aumentada empleada por el procedimiento de Local Search, que se repite varias veces utilizando los últimos óptimos locales descubiertos y la función de costo aumentada que guía la exploración lejos de las soluciones con características presentes en los óptimos locales descubiertos."
  },
  {
    "objectID": "posts/2023-11-19-guided_local_search/index.html#procedimiento",
    "href": "posts/2023-11-19-guided_local_search/index.html#procedimiento",
    "title": "Guided Local serach",
    "section": "Procedimiento",
    "text": "Procedimiento\nEl algoritmo de Local Search utilizado por el algoritmo de Guided Local Search utiliza una función de costo aumentada de la forma \\(h(s) = g(s)+ 𝞴*∑_{i=1}^Mf_i\\), donde \\(h(s)\\) es la función de costo aumentada, \\(g(s)\\) es la función de costo del problema, es el `parámetro de regularización’ (un coeficiente para escalar las penalizaciones), \\(s\\) es una solución localmente óptima de \\(M\\) características, y \\(f_i\\) es la \\(i\\)-ésima característica en la solución localmente óptima. La función de costos aumentada sólo la utiliza el procedimiento de Local Search, mientras que el algoritmo Guided Local Search utiliza la función de costos específica del problema sin aumento.\nLas penalizaciones sólo se actualizan para aquellas características en una solución localmente óptima que maximizan la utilidad, actualizadas añadiendo 1 a la penalización para el futuro (un contador). La utilidad de una característica se calcula como \\(U_{feature} = C_{feature} / (1+P_{feaure})\\) , donde \\(U_{feaure}\\) es la utilidad de penalizar una característica (maximizar), \\(C_{feaure}\\) es el costo de la característica y \\(P_{feature}\\) es la penalización actual para la característica.\n\n\n\nPseudocódigo Guided Local Search"
  },
  {
    "objectID": "posts/2023-11-19-guided_local_search/index.html#heurística",
    "href": "posts/2023-11-19-guided_local_search/index.html#heurística",
    "title": "Guided Local serach",
    "section": "Heurística",
    "text": "Heurística\nEl procedimiento de Guided Local Search es independiente del procedimiento de Local Search integrado en él. Debe identificarse y emplearse un procedimiento de búsqueda específico del dominio.\nEl procedimiento de Guided Local Search puede tener que ejecutarse durante miles a cientos de miles de iteraciones, cada iteración supone una ejecución de un algoritmo de Local Search hasta la convergencia.\nEl algoritmo se diseñó para problemas de optimización discretos en los que una solución se compone de “características” evaluables independientemente como la Optimización Combinatoria, aunque se ha aplicado a la optimización de funciones continuas modeladas como cadenas binarias.\nEl parámetro \\(𝞴\\) es un factor de escala para la penalización de características que debe estar en la misma proporción que los costos de la solución candidata del problema específico al que se aplica el algoritmo. Como tal, el valor para \\(𝞴\\) debe ser significativo cuando se utiliza dentro de la función de costo aumentada (como cuando se añade a un costo de una solución candidata en la minimización y se resta de un en el caso de un problema de maximización)."
  },
  {
    "objectID": "posts/2023-11-19-guided_local_search/index.html#código",
    "href": "posts/2023-11-19-guided_local_search/index.html#código",
    "title": "Guided Local serach",
    "section": "Código",
    "text": "Código\nEl algoritmo se aplica a la instancia Berlin52 de Travling Salesman Problem (TSP), tomada de la TSPLIB. El problema busca una permutación del orden de visita de las ciudades (llamada tour o recorrido) que minimice la distancia total recorrida. La distancia óptima del recorrido para el caso Berlín52 es de 7.542 unidades. Se utiliza un algoritmo de Local Search 2-opt que selecciona dos puntos en una permutación y reconecta el tour, potencialmente desenrollando el tour en los puntos seleccionados. La condición de parada para 2-opt es un número fijo de movimientos no mejorables.\nLa ecuación para ajustar \\(𝞴\\) para instancias de TSP es \\(𝞴 = ⍺ * costo(optima)/N\\) , donde \\(N\\) es el número de ciudades, \\(costo(optima)\\) es el costo de un óptimo local encontrado mediante una búsqueda local, y \\(⍺ ∈ (0,1]\\) (alrededor de 0,3 para TSP y 2-opt). El costo de un óptimo local se fijó en el valor aproximado de 15.000 para el TSP de Berlín52. La función de utilidad para las características (aristas) en el TSP es \\(U_{edge} = D_{edge}/(1+P_{edge})\\) donde \\(U_{edge}\\) es la utilidad de penalizar una arista (maximizar), \\(D_{edge}\\) es el coste de la arista (distancia entre ciudades) y \\(P_{edge}\\) es la penalización actual de la arista.\n\n# Función para calcular la distancia euclidiana entre dos puntos\neuc_2d &lt;- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Función para generar una permutación aleatoria de las ciudades\nrandom_permutation &lt;- function(cities) {\n    return(sample(nrow(cities)))\n}\n\n# Función para realizar una operación de dos-opt estocástica en una permutación\nstochastic_two_opt &lt;- function(permutation) {\n    perm &lt;- permutation\n    c1 &lt;- sample(length(perm), 1)\n    exclude &lt;- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 &lt;- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 &lt;- sample(length(perm), 1)\n    }\n    if (c2 &lt; c1) {\n        temp &lt;- c1\n        c1 &lt;- c2\n        c2 &lt;- temp\n    }\n    perm[c1:c2] &lt;- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Función para calcular el costo y el costo aumentado de una permutación\naugmented_cost &lt;- function(permutation, penalties, cities, lambda) {\n    distance &lt;- 0\n    augmented &lt;- 0\n    for (i in seq_along(permutation)) {\n        c1 &lt;- permutation[i]\n        c2 &lt;- if (i == length(permutation)) permutation[1] else permutation[i + 1]\n        if (c2 &lt; c1) {\n            temp &lt;- c1\n            c1 &lt;- c2\n            c2 &lt;- temp\n        }\n        d &lt;- euc_2d(cities[c1, ], cities[c2, ])\n        distance &lt;- distance + d\n        augmented &lt;- augmented + d + (lambda * penalties[c1, c2])\n    }\n    return(c(distance, augmented))\n}\n\n# Función para calcular el costo de un candidato\ncost &lt;- function(cand, penalties, cities, lambda) {\n    costs &lt;- augmented_cost(cand$vector, penalties, cities, lambda)\n    cand$cost &lt;- costs[1]\n    cand$aug_cost &lt;- costs[2]\n    return(cand)\n}\n\n# Función para realizar una búsqueda local en el espacio de las permutaciones\nlocal_search &lt;- function(current, cities, penalties, max_no_improv, lambda) {\n    current &lt;- cost(current, penalties, cities, lambda)\n    count &lt;- 0\n    repeat {\n        candidate &lt;- list()\n        candidate$vector &lt;- stochastic_two_opt(current$vector)\n        candidate &lt;- cost(candidate, penalties, cities, lambda)\n        if (candidate$aug_cost &lt; current$aug_cost) {\n            count &lt;- 0\n            current &lt;- candidate\n        } else {\n            count &lt;- count + 1\n        }\n        if (count &gt;= max_no_improv) break\n    }\n    return(current)\n}\n\n# Función para calcular las utilidades de las características\ncalculate_feature_utilities &lt;- function(penal, cities, permutation) {\n    utilities &lt;- numeric(length(permutation))\n    for (i in seq_along(permutation)) {\n        c1 &lt;- permutation[i]\n        c2 &lt;- if (i == length(permutation)) permutation[1] else permutation[i + 1]\n        if (c2 &lt; c1) {\n            temp &lt;- c1\n            c1 &lt;- c2\n            c2 &lt;- temp\n        }\n        utilities[i] &lt;- euc_2d(cities[c1, ], cities[c2, ]) / (1.0 + penal[c1, c2])\n    }\n    return(utilities)\n}\n\n# Función para actualizar las penalizaciones\nupdate_penalties &lt;- function(penalties, cities, permutation, utilities) {\n    max_utility &lt;- max(utilities)\n    for (i in seq_along(permutation)) {\n        c1 &lt;- permutation[i]\n        c2 &lt;- ifelse(i == length(permutation), permutation[1], permutation[i + 1])\n        if (c2 &lt; c1) {\n            temp &lt;- c1\n            c1 &lt;- c2\n            c2 &lt;- temp\n        }\n        penalties[c1, c2] &lt;- ifelse(utilities[i] == max_utility, penalties[c1, c2] + 1, penalties[c1, c2])\n    }\n    return(penalties)\n}\n\n# Función de búsqueda principal\nsearch &lt;- function(max_iterations, cities, max_no_improv, lambda) {\n    current &lt;- list()\n    current$vector &lt;- random_permutation(cities)\n    best &lt;- NULL\n    penalties &lt;- matrix(0, nrow = nrow(cities), ncol = nrow(cities))\n    cost_progress &lt;- data.frame(iteration=integer(), cost=numeric()) # Para llevar el seguimiento del progreso del costo\n    for (iter in seq_len(max_iterations)) {\n        current &lt;- local_search(current, cities, penalties, max_no_improv, lambda)\n        utilities &lt;- calculate_feature_utilities(penalties, cities, current$vector)\n        penalties &lt;- update_penalties(penalties, cities, current$vector, utilities)\n        if (is.null(best) || current$cost &lt; best$cost) {\n            best &lt;- current\n        }\n        cost_progress &lt;- rbind(cost_progress, data.frame(iteration=iter, cost=best$cost)) # Registrar el costo en cada iteración\n        #print(paste(\" &gt; iter =\", iter + 1, \", best =\", best$cost, \", aug =\", best$aug_cost))\n    }\n    return(list(best=best, cost_progress=cost_progress)) # Devolver tanto la mejor solución como el progreso del costo\n}\n\n\n# Configuración del problema\nberlin52 &lt;- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,\n                     300,465,520,585,480,415,835,625,975,580,\n                     1215,245,1320,315,1250,400,660,180,410,250,\n                     420,555,575,665,1150,1160,700,580,685,595,\n                     685,610,770,610,795,645,720,635,760,650,\n                     475,960,95,260,875,920,700,500,555,815,\n                     830,485,1170,65,830,610,605,625,595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iterations &lt;- 150\nmax_no_improv &lt;- 20\nalpha &lt;- 0.3\nlocal_search_optima &lt;- 12000.0\nlambda &lt;- alpha * (local_search_optima / nrow(berlin52))\n\n# Ejecutar el algoritmo\nresult &lt;- search(max_iterations, berlin52, max_no_improv, lambda)\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\nlibrary(ggplot2)\n\ncrear_tema &lt;- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(result$cost_progress, aes(x=iteration, y=cost)) +\n    geom_line() +\n    labs(title=\"Progreso del costo a lo largo de las iteraciones\", x=\"Iteración\", y=\"Costo\")+\n    crear_tema()\n\n\n\n\n\n\n\n\nLa solución óptima (con las iteraciones establecidas) es entonces:\n\nresult$best$vector\n\n [1] 32 44 34 35 37 40 39 36 38 15  6  5 24 48 46 16 47 27 14 13 52 11 51 12 28\n[26] 26 25  4 43 33 10  9  8 41 19 18 21 42  7  2 30 29 20 50 23 22 49  1 31 17\n[51]  3 45"
  },
  {
    "objectID": "posts/2023-12-03-variable_neighborhood_search/index.html",
    "href": "posts/2023-12-03-variable_neighborhood_search/index.html",
    "title": "Variable Neighborhood Search",
    "section": "",
    "text": "Variable Neighborhood Search es una Metaheurística y una técnica de Optimización Global que administra una técnica de Local Search. Está relacionada con el algoritmo de Iterated Local Search."
  },
  {
    "objectID": "posts/2023-12-03-variable_neighborhood_search/index.html#taxonomía",
    "href": "posts/2023-12-03-variable_neighborhood_search/index.html#taxonomía",
    "title": "Variable Neighborhood Search",
    "section": "",
    "text": "Variable Neighborhood Search es una Metaheurística y una técnica de Optimización Global que administra una técnica de Local Search. Está relacionada con el algoritmo de Iterated Local Search."
  },
  {
    "objectID": "posts/2023-12-03-variable_neighborhood_search/index.html#estrategia",
    "href": "posts/2023-12-03-variable_neighborhood_search/index.html#estrategia",
    "title": "Variable Neighborhood Search",
    "section": "Estrategia",
    "text": "Estrategia\nLa estrategia para Variable Neighborhood Search implica la exploración iterativa de vecindarios cada vez más grandes para un óptimo local dado hasta que se localiza una mejora, tras lo cual se repite la búsqueda a través de vecindarios en expansión. La estrategia está motivada por tres principios 1) un mínimo local para una estructura de vecindad puede no ser un mínimo local para una estructura de vecindad diferente, 2) un mínimo global es un mínimo local para todas las estructuras de vecindad posibles, y 3) los mínimos locales están relativamente cerca de los mínimos globales en muchas clases de problemas."
  },
  {
    "objectID": "posts/2023-12-03-variable_neighborhood_search/index.html#procedimiento",
    "href": "posts/2023-12-03-variable_neighborhood_search/index.html#procedimiento",
    "title": "Variable Neighborhood Search",
    "section": "Procedimiento",
    "text": "Procedimiento\nEl pseudocódigo muestra que la búsqueda sistemática de vecindarios en expansión para un óptimo local se abandona cuando se alcanza una mejora global (mostrada con el salto Break).\n\n\n\nPseudocódigo Variable Neighborhood Search"
  },
  {
    "objectID": "posts/2023-12-03-variable_neighborhood_search/index.html#heurística",
    "href": "posts/2023-12-03-variable_neighborhood_search/index.html#heurística",
    "title": "Variable Neighborhood Search",
    "section": "Heurística",
    "text": "Heurística\nSe sugiere el uso de métodos de aproximación (como Stochastic Hill Climbing) como procedimiento de Local Search para instancias de problemas grandes con el fin de reducir el tiempo de ejecución.\nVariable Neighborhood Search se ha aplicado a una amplia gama de problemas de optimización combinatoria, así como a problemas de agrupación (clustering) y optimización de funciones continuas.\nLa técnica de Local Search incrustada debe especializarse según el tipo de problema y la instancia a la que se aplica la técnica.\nVariable Neighborhood Descent (VND) se puede incrustar en Variable Neighborhood Search como un procedimiento de Local Search y ha demostrado ser el más eficaz."
  },
  {
    "objectID": "posts/2023-12-03-variable_neighborhood_search/index.html#código",
    "href": "posts/2023-12-03-variable_neighborhood_search/index.html#código",
    "title": "Variable Neighborhood Search",
    "section": "Código",
    "text": "Código\nEl algoritmo se aplica a la instancia Berlin52 de Travling Salesman Problem (TSP), tomada de la TSPLIB. El problema busca una permutación del orden de visita de las ciudades (llamada tour o recorrido) que minimice la distancia total recorrida. La distancia óptima del recorrido para el caso Berlín52 es de 7.542 unidades.\nVariable Neighborhood Search utiliza un procedimiento estocástico 2-opt como Local Serach incrustada. El procedimiento elimina dos aristas e invierte la secuencia entre las aristas eliminadas, eliminando potencialmente “giros” en el recorrido. La estructura de vecindad utilizada en la búsqueda es el número de veces que se realiza el procedimiento 2-opt en una permutación, entre 1 y 20 veces. La condición de parada para el procedimiento de Local Search es un número máximo de iteraciones sin mejora.\nLa misma condición de parada es empleada por el procedimiento de orden superior Variable Neighborhood Search aunque con un límite inferior en el número de iteraciones sin mejora.\n\n# Función para calcular la distancia euclidiana entre dos puntos\neuc_2d &lt;- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Función para calcular el costo de una permutación de ciudades\ncost &lt;- function(perm, cities) {\n    distance &lt;- 0\n    for (i in seq_along(perm)) {\n        c1 &lt;- perm[i]\n        c2 &lt;- if (i == length(perm)) perm[1] else perm[i + 1]\n        distance &lt;- distance + euc_2d(cities[c1, ], cities[c2, ])\n    }\n    return(distance)\n}\n\n# Función para generar una permutación aleatoria de las ciudades\nrandom_permutation &lt;- function(cities) {\n    return(sample(nrow(cities)))\n}\n\n# Función para realizar una operación de dos-opt estocástica en una permutación\nstochastic_two_opt &lt;- function(perm) {\n    c1 &lt;- sample(length(perm), 1)\n    exclude &lt;- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 &lt;- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 &lt;- sample(length(perm), 1)\n    }\n    if (c2 &lt; c1) {\n        temp &lt;- c1\n        c1 &lt;- c2\n        c2 &lt;- temp\n    }\n    perm[c1:c2] &lt;- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Función para realizar una búsqueda local en el espacio de las permutaciones\nlocal_search &lt;- function(best, cities, max_no_improv, neighborhood) {\n    count &lt;- 0\n    repeat {\n        candidate &lt;- list()\n        candidate$vector &lt;- stochastic_two_opt(best$vector)\n        candidate$cost &lt;- cost(candidate$vector, cities)\n        if (candidate$cost &lt; best$cost) {\n            count &lt;- 0\n            best &lt;- candidate\n        } else {\n            count &lt;- count + 1\n        }\n        if (count &gt;= max_no_improv) break\n    }\n    return(best)\n}\n\n# Función de búsqueda principal\nsearch &lt;- function(cities, neighborhoods, max_no_improv, max_no_improv_ls) {\n    best &lt;- list()\n    best$vector &lt;- random_permutation(cities)\n    best$cost &lt;- cost(best$vector, cities)\n    iter &lt;- 0\n    count &lt;- 0\n    stop_loop &lt;- FALSE\n    # Creamos un dataframe para guardar las soluciones\n    solutions &lt;- data.frame(iteration=integer(), cost=double())\n    for (neigh in neighborhoods) {\n        if (stop_loop) {\n            break\n        }\n        candidate &lt;- list()\n        candidate$vector &lt;- best$vector\n        for (i in seq_len(neigh)) {\n            candidate$vector &lt;- stochastic_two_opt(candidate$vector)\n        }\n        candidate$cost &lt;- cost(candidate$vector, cities)\n        candidate &lt;- local_search(candidate, cities, max_no_improv_ls, neigh)\n        cat(\" &gt; iteration\", iter + 1, \", neigh=\", neigh, \", best=\", best$cost, \"\\n\")\n        iter &lt;- iter + 1\n        # Guardamos la solución en el dataframe\n        solutions &lt;- rbind(solutions, data.frame(iteration=iter, cost=best$cost))\n        if (candidate$cost &lt; best$cost) {\n            best &lt;- candidate\n            count &lt;- 0\n            cat(\"New best, restarting neighborhood search.\\n\")\n        } else {\n            count &lt;- count + 1\n        }\n        if (count &gt;= max_no_improv) {\n            stop_loop &lt;- TRUE\n        }\n    }\n    return(solutions)\n}\n\n# Configuración del problema\nberlin52 &lt;- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,\n                     300,465,520,585,480,415,835,625,975,580,\n                     1215,245,1320,315,1250,400,660,180,410,250,\n                     420,555,575,665,1150,1160,700,580,685,595,\n                     685,610,770,610,795,645,720,635,760,650,475,\n                     960,95,260,875,920,700,500,555,815,830,485,\n                     1170,65,830,610,605,625,595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_no_improv &lt;- 50\nmax_no_improv_ls &lt;- 70\nneighborhoods &lt;- 1:20\n\n# Ejecutar el algoritmo\nbest &lt;- search(berlin52, neighborhoods, max_no_improv, max_no_improv_ls)\n\n &gt; iteration 1 , neigh= 1 , best= 27083 \nNew best, restarting neighborhood search.\n &gt; iteration 2 , neigh= 2 , best= 12602 \nNew best, restarting neighborhood search.\n &gt; iteration 3 , neigh= 3 , best= 10777 \n &gt; iteration 4 , neigh= 4 , best= 10777 \n &gt; iteration 5 , neigh= 5 , best= 10777 \n &gt; iteration 6 , neigh= 6 , best= 10777 \n &gt; iteration 7 , neigh= 7 , best= 10777 \nNew best, restarting neighborhood search.\n &gt; iteration 8 , neigh= 8 , best= 10637 \n &gt; iteration 9 , neigh= 9 , best= 10637 \nNew best, restarting neighborhood search.\n &gt; iteration 10 , neigh= 10 , best= 10606 \n &gt; iteration 11 , neigh= 11 , best= 10606 \n &gt; iteration 12 , neigh= 12 , best= 10606 \n &gt; iteration 13 , neigh= 13 , best= 10606 \n &gt; iteration 14 , neigh= 14 , best= 10606 \n &gt; iteration 15 , neigh= 15 , best= 10606 \n &gt; iteration 16 , neigh= 16 , best= 10606 \n &gt; iteration 17 , neigh= 17 , best= 10606 \nNew best, restarting neighborhood search.\n &gt; iteration 18 , neigh= 18 , best= 10388 \nNew best, restarting neighborhood search.\n &gt; iteration 19 , neigh= 19 , best= 10047 \n &gt; iteration 20 , neigh= 20 , best= 10047 \nNew best, restarting neighborhood search.\n\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\nlibrary(ggplot2)\n\ncrear_tema &lt;- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(best, aes(x=iteration, y=cost)) +\n    geom_line() +\n    labs(title=\"Progreso del costo a lo largo de las iteraciones\", x=\"Iteración\", y=\"Costo\")+\n    crear_tema()"
  },
  {
    "objectID": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html",
    "href": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html",
    "title": "Greedy Randomized Adaptative Search",
    "section": "",
    "text": "El Procedimiento de Greedy Randomized Adaptative Search es un algoritmo Metaheurístico y de Optimización Global, originalmente propuesto para los practicantes de la Investigación de Operaciones. La aplicación iterativa de una técnica de Local Search incrustada relaciona el enfoque con Iterated Local Search y las técnicas de Multi-Start."
  },
  {
    "objectID": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#taxonomía",
    "href": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#taxonomía",
    "title": "Greedy Randomized Adaptative Search",
    "section": "",
    "text": "El Procedimiento de Greedy Randomized Adaptative Search es un algoritmo Metaheurístico y de Optimización Global, originalmente propuesto para los practicantes de la Investigación de Operaciones. La aplicación iterativa de una técnica de Local Search incrustada relaciona el enfoque con Iterated Local Search y las técnicas de Multi-Start."
  },
  {
    "objectID": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#estrategia",
    "href": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#estrategia",
    "title": "Greedy Randomized Adaptative Search",
    "section": "Estrategia",
    "text": "Estrategia\nEl objetivo del Greedy Randomized Adaptative Search es muestrear repetidamente soluciones codiciosas y, a continuación, utilizar un procedimiento de Local Search para refinarlas hasta alcanzar un óptimo local. La estrategia del procedimiento se centra en el mecanismo de construcción por pasos estocásticos y codiciosos que restringe la selección y el orden de inclusión de los componentes de una solución en función del valor que se espera que aporten."
  },
  {
    "objectID": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#procedimiento",
    "href": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#procedimiento",
    "title": "Greedy Randomized Adaptative Search",
    "section": "Procedimiento",
    "text": "Procedimiento\nSe presenta un pseudocódigo del Greedy Randomized Adaptative Search para minimizar una función de costo.\n\n\n\nPseudocódigo Greedy Randomized Adaptative Search\n\n\nAdemás, el pseudocódigo de la función de construcción aleatoria codiciosa. La función consiste en la construcción paso a paso de una solución candidata utilizando un proceso de construcción estocástico. La función trabaja construyendo una Lista Restringida de Candidatos (RCL por sus siglas en inglés) que restringe los componentes de una solución (características) que pueden seleccionarse en cada ciclo. La RCL puede limitarse mediante un tamaño explícito o utilizando un umbral \\((⍺ ∈ [0,1])\\) en el costo de añadir cada característica a la solución candidata actual.\n\n\n\nPseudocódigo Función de Construcción"
  },
  {
    "objectID": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#heurística",
    "href": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#heurística",
    "title": "Greedy Randomized Adaptative Search",
    "section": "Heurística",
    "text": "Heurística\nEl umbral \\(⍺\\) define el grado de avaricia del mecanismo de construcción, donde valores cercanos a 0 pueden ser demasiado codiciosos, y valores cercanos a 1 pueden ser demasiado generalizados.\nComo alternativa al uso del umbral \\(⍺\\), el RCL se puede puede limitarse al top \\(n%\\) de las características candidatas que pueden seleccionarse en cada ciclo de construcción.\nLa técnica se diseñó para clases de problemas discretos, como los problemas de optimización combinatoria."
  },
  {
    "objectID": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#código",
    "href": "posts/2023-12-08-greedy_randomized_adaptative_search/index.html#código",
    "title": "Greedy Randomized Adaptative Search",
    "section": "Código",
    "text": "Código\nEl algoritmo se aplica a la instancia Berlin52 de Travling Salesman Problem (TSP), tomada de la TSPLIB. El problema busca una permutación del orden de visita de las ciudades (llamada tour o recorrido) que minimice la distancia total recorrida. La distancia óptima del recorrido para el caso Berlín52 es de 7.542 unidades.\nLa construcción estocástica y codiciosa por pasos de un recorrido implica la evaluación de las ciudades candidatas por el costo que aportan por ser la siguiente ciudad del recorrido. El algoritmo utiliza un procedimiento estocástico 2-opt para Local Search con un número fijo de iteraciones no mejoradas como como condición de parada.\n\n# Función para calcular la distancia euclidiana entre dos puntos\neuc_2d &lt;- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Función para calcular el costo de una permutación de ciudades\ncost &lt;- function(perm, cities) {\n    distance &lt;- 0\n    for (i in seq_along(perm)) {\n        c1 &lt;- perm[i]\n        c2 &lt;- if (i == length(perm)) perm[1] else perm[i + 1]\n        distance &lt;- distance + euc_2d(cities[c1, ], cities[c2, ])\n    }\n    return(distance)\n}\n\n# Función para realizar una operación de dos-opt estocástica en una permutación\nstochastic_two_opt &lt;- function(permutation) {\n    perm &lt;- permutation\n    c1 &lt;- sample(length(perm), 1)\n    exclude &lt;- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 &lt;- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 &lt;- sample(length(perm), 1)\n    }\n    if (c2 &lt; c1) {\n        temp &lt;- c1\n        c1 &lt;- c2\n        c2 &lt;- temp\n    }\n    perm[c1:c2] &lt;- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Función para realizar una búsqueda local en el espacio de las permutaciones\nlocal_search &lt;- function(best, cities, max_no_improv) {\n    count &lt;- 0\n    repeat {\n        candidate &lt;- list()\n        candidate$vector &lt;- stochastic_two_opt(best$vector)\n        candidate$cost &lt;- cost(candidate$vector, cities)\n        if (candidate$cost &lt; best$cost) {\n            count &lt;- 0\n            best &lt;- candidate\n        } else {\n            count &lt;- count + 1\n        }\n        if (count &gt;= max_no_improv) break\n    }\n    return(best)\n}\n\n# Función para construir una solución codiciosa aleatorizada\nconstruct_randomized_greedy_solution &lt;- function(cities, alpha) {\n    candidate &lt;- list()\n    candidate$vector &lt;- sample(1:nrow(cities), 1)\n    allCities &lt;- 1:nrow(cities)\n    while (length(candidate$vector) &lt; nrow(cities)) {\n        candidates &lt;- setdiff(allCities, candidate$vector)\n        costs &lt;- sapply(candidates, function(i) euc_2d(cities[candidate$vector[length(candidate$vector)], ], cities[i, ]))\n        rcl &lt;- candidates[which(costs &lt;= min(costs) + alpha * (max(costs) - min(costs)))]\n        candidate$vector &lt;- c(candidate$vector, sample(rcl, 1))\n    }\n    candidate$cost &lt;- cost(candidate$vector, cities)\n    return(candidate)\n}\n\n# Función de búsqueda principal\nsearch &lt;- function(cities, max_iter, max_no_improv, alpha) {\n    best &lt;- NULL\n    cost_progress &lt;- list()  # Lista para registrar el progreso del costo\n    for (iter in seq_len(max_iter)) {\n        candidate &lt;- construct_randomized_greedy_solution(cities, alpha)\n        candidate &lt;- local_search(candidate, cities, max_no_improv)\n        if (is.null(best) || candidate$cost &lt; best$cost) {\n            best &lt;- candidate\n        }\n        cost_progress[[iter]] &lt;- best$cost  # Registrar el costo en la lista\n        cat(\" &gt; iteration\", iter, \", best=\", best$cost, \"\\n\")\n    }\n    return(list(best = best, cost_progress = cost_progress))  # Devolver la mejor solución y el progreso del costo\n}\n\n# Configuración del problema\nberlin52 &lt;- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,300,\n                     465,520,585,480,415,835,625,975,580,1215,245,\n                     1320,315,1250,400,660,180,410,250,420,555,575,\n                     665,1150,1160,700,580,685,595,685,610,770,610,\n                     795,645,720,635,760,650,475,960,95,260,875,920,\n                     700,500,555,815,830,485,1170,65,830,610,605,625,\n                     595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iter &lt;- 50\nmax_no_improv &lt;- 50\ngreediness_factor &lt;- 0.3\n\n# Ejecutar el algoritmo\nresult &lt;- search(berlin52, max_iter, max_no_improv, greediness_factor)\n\n &gt; iteration 1 , best= 13720 \n &gt; iteration 2 , best= 10869 \n &gt; iteration 3 , best= 9540 \n &gt; iteration 4 , best= 9540 \n &gt; iteration 5 , best= 9540 \n &gt; iteration 6 , best= 9540 \n &gt; iteration 7 , best= 9540 \n &gt; iteration 8 , best= 9540 \n &gt; iteration 9 , best= 9540 \n &gt; iteration 10 , best= 9540 \n &gt; iteration 11 , best= 9540 \n &gt; iteration 12 , best= 9540 \n &gt; iteration 13 , best= 9540 \n &gt; iteration 14 , best= 9540 \n &gt; iteration 15 , best= 9540 \n &gt; iteration 16 , best= 9540 \n &gt; iteration 17 , best= 9540 \n &gt; iteration 18 , best= 9540 \n &gt; iteration 19 , best= 9540 \n &gt; iteration 20 , best= 9540 \n &gt; iteration 21 , best= 9540 \n &gt; iteration 22 , best= 9540 \n &gt; iteration 23 , best= 9540 \n &gt; iteration 24 , best= 9540 \n &gt; iteration 25 , best= 9540 \n &gt; iteration 26 , best= 9540 \n &gt; iteration 27 , best= 9540 \n &gt; iteration 28 , best= 9540 \n &gt; iteration 29 , best= 9540 \n &gt; iteration 30 , best= 9540 \n &gt; iteration 31 , best= 9540 \n &gt; iteration 32 , best= 9540 \n &gt; iteration 33 , best= 9540 \n &gt; iteration 34 , best= 9540 \n &gt; iteration 35 , best= 9540 \n &gt; iteration 36 , best= 9540 \n &gt; iteration 37 , best= 9540 \n &gt; iteration 38 , best= 9540 \n &gt; iteration 39 , best= 9540 \n &gt; iteration 40 , best= 9540 \n &gt; iteration 41 , best= 9540 \n &gt; iteration 42 , best= 9540 \n &gt; iteration 43 , best= 9540 \n &gt; iteration 44 , best= 9540 \n &gt; iteration 45 , best= 9540 \n &gt; iteration 46 , best= 9540 \n &gt; iteration 47 , best= 9540 \n &gt; iteration 48 , best= 9540 \n &gt; iteration 49 , best= 9540 \n &gt; iteration 50 , best= 9540 \n\nbest &lt;- result$best\ncost_progress &lt;- result$cost_progress\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\nlibrary(ggplot2)\n\ncrear_tema &lt;- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\ndf &lt;- data.frame(iteration = 1:max_iter, cost = unlist(cost_progress))\nggplot(df, aes(x = iteration, y = cost)) +\n    geom_line() +\n    labs(title = \"Progreso del costo a lo largo de las iteraciones\",\n         x = \"Iteración\",\n         y = \"Costo\")+\n    crear_tema()"
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html",
    "href": "posts/2024-11-18-intro_git/index.html",
    "title": "Introducción a Git",
    "section": "",
    "text": "En este módulo, obtendrás una introducción al control de versiones, y a Git. Git puede parecer un poco críptico al principio, e incluso puede ser frustrante a veces. Pero si lo aprendes paso a paso, descubrirás que hay una razón por la que Git se está convirtiendo rápidamente en el sistema de control de versiones más popular del mundo, no sólo para desarrolladores de software, sino también para equipos que escriben documentación y colaboran en otros trabajos."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#introducción",
    "href": "posts/2024-11-18-intro_git/index.html#introducción",
    "title": "Introducción a Git",
    "section": "",
    "text": "En este módulo, obtendrás una introducción al control de versiones, y a Git. Git puede parecer un poco críptico al principio, e incluso puede ser frustrante a veces. Pero si lo aprendes paso a paso, descubrirás que hay una razón por la que Git se está convirtiendo rápidamente en el sistema de control de versiones más popular del mundo, no sólo para desarrolladores de software, sino también para equipos que escriben documentación y colaboran en otros trabajos."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#objetivos-de-aprendizaje",
    "href": "posts/2024-11-18-intro_git/index.html#objetivos-de-aprendizaje",
    "title": "Introducción a Git",
    "section": "Objetivos de aprendizaje",
    "text": "Objetivos de aprendizaje\nEn este módulo:\n\nAprenderás qué es el control de versiones.\nEntender los sistemas de control de versiones distribuidos, como Git.\nReconocer las diferencias entre Git y GitHub y las funciones que desempeñan en el ciclo de vida de desarrollo de software."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#qué-es-el-control-de-versiones",
    "href": "posts/2024-11-18-intro_git/index.html#qué-es-el-control-de-versiones",
    "title": "Introducción a Git",
    "section": "¿Qué es el control de versiones?",
    "text": "¿Qué es el control de versiones?\nUn sistema de control de versiones (VCS) es un programa o conjunto de programas que rastrea los cambios realizados en una colección de archivos. Uno de los objetivos de un VCS es recuperar fácilmente versiones anteriores de archivos individuales o de todo el proyecto. Otro objetivo es permitir que varios miembros de un equipo trabajen en un proyecto, incluso en los mismos archivos, al mismo tiempo sin afectar al trabajo de los demás.\nOtro nombre para un VCS es sistema de gestión de configuración de software (SCM). De hecho, la documentación oficial de Git se encuentra en git-scm.com. Técnicamente, el control de versiones es sólo una de las prácticas implicadas en la SCM. Un VCS puede utilizarse para proyectos distintos del software, incluidos libros y tutoriales en línea.\nCon un VCS, puedes:\n\nVer todos los cambios realizados en tu proyecto, cuándo se hicieron y quién los hizo.\nIncluir un mensaje con cada cambio para explicar los motivos del mismo.\nRecuperar versiones anteriores de todo el proyecto o de archivos individuales.\nCrear ramas, donde se pueden realizar cambios de forma experimental. Esta función permite trabajar en varios conjuntos diferentes de cambios (por ejemplo, características o correcciones de errores) al mismo tiempo, posiblemente por diferentes personas, sin afectar a la rama principal. Más tarde, puedes fusionar los cambios que quieras conservar en la rama principal.\nAdjunta una etiqueta a una versión, por ejemplo, para marcar una nueva versión.\n\nGit es un VCS rápido, versátil, altamente escalable, gratuito y de código abierto. Su principal autor es Linus Torvalds, el creador de Linux."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#control-de-versiones-distribuido",
    "href": "posts/2024-11-18-intro_git/index.html#control-de-versiones-distribuido",
    "title": "Introducción a Git",
    "section": "Control de versiones distribuido",
    "text": "Control de versiones distribuido\nLos primeros VCS, como CVS, Subversion (SVN) y Perforce, utilizaban un servidor centralizado para almacenar el historial de un proyecto. Esta centralización significaba que el único servidor era también potencialmente un único punto de fallo.\nGit es distribuido, lo que significa que el historial completo de un proyecto se almacena tanto en el cliente como en el servidor. Puedes editar archivos sin conexión a la red, comprobarlos localmente y sincronizarlos con el servidor cuando haya una conexión disponible. Si un servidor se cae, sigues teniendo una copia local del proyecto. Técnicamente, ni siquiera hace falta tener un servidor. Los cambios pueden ser enviados por correo electrónico o compartidos mediante el uso de medios extraíbles, pero nadie utiliza Git de esta manera en la práctica."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#terminología-de-git",
    "href": "posts/2024-11-18-intro_git/index.html#terminología-de-git",
    "title": "Introducción a Git",
    "section": "Terminología de Git",
    "text": "Terminología de Git\nPara entender Git, tienes que entender su terminología. Aquí tienes una pequeña lista de términos que los usuarios de Git utilizan con frecuencia. No te preocupes por los detalles por ahora; todos estos términos te resultarán familiares a medida que vayas avanzando en los ejercicios de este módulo.\n\nÁrbol de trabajo: El conjunto de directorios y archivos anidados que contienen el proyecto en el que se está trabajando.\nRepositorio (repo): El directorio, situado en el nivel superior de un árbol de trabajo, donde Git guarda toda la historia y metadatos de un proyecto. Los repositorios casi siempre se denominan repos. Un repositorio vacío es aquel que no forma parte de un árbol de trabajo; se utiliza para compartir o hacer copias de seguridad. Un repositorio vacío es normalmente un directorio con un nombre que termina en .git-por ejemplo, proyecto.git.\nHash: Un número producido por una función hash que representa el contenido de un archivo u otro objeto como un número fijo de dígitos. Git utiliza hashes de 160 bits de longitud. Una ventaja de usar hashes es que Git puede saber si un archivo ha cambiado haciendo un hash de su contenido y comparando el resultado con el hash anterior. Si la fecha y hora del archivo cambia, pero el hash del archivo no, Git sabe que el contenido del archivo no ha cambiado.\nObjetos: Un repositorio Git contiene cuatro tipos de objetos, cada uno identificado de forma única por un hash SHA-1. Un objeto blob contiene un archivo ordinario. Un objeto tree representa un directorio; contiene nombres, hashes y permisos. Un objeto commit representa una versión específica del árbol de trabajo. Una etiqueta es un nombre asociado a una confirmación.\nCommit: Cuando se utiliza como verbo, commit significa crear un objeto commit. Esta acción toma su nombre de las confirmaciones a una base de datos. Significa que estás confirmando los cambios que has hecho para que otros también puedan verlos.\nRama: Una rama es una serie de confirmaciones enlazadas. El commit más reciente de una rama se denomina head. La rama por defecto, que se crea cuando inicializas un repositorio, se llama main, a menudo llamada master en Git. La cabecera de la rama actual se llama HEAD. Las ramas son una característica increíblemente útil de Git porque permiten a los desarrolladores trabajar independientemente (o juntos) en ramas y más tarde fusionar sus cambios en la rama por defecto.\nRemoto: Un remoto es una referencia con nombre a otro repositorio Git. Cuando creas un repositorio, Git crea un remoto llamado origen, que es el remoto por defecto para las operaciones push y pull.\nComandos, subcomandos y opciones: Las operaciones de Git se realizan usando comandos como git push y git pull. git es el comando, y push o pull es el subcomando. El subcomando especifica la operación que quieres que Git realice. Los comandos suelen ir acompañados de opciones, que utilizan guiones (-) o guiones dobles (–). Por ejemplo, git reset --hard.\n\nEstos términos y otros, como «empujar» y « tirar», tendrán más sentido en breve. Pero tienes que empezar por algún sitio, y puede que te resulte útil volver y revisar este glosario de términos cuando termines el módulo."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#la-línea-de-comandos-de-git",
    "href": "posts/2024-11-18-intro_git/index.html#la-línea-de-comandos-de-git",
    "title": "Introducción a Git",
    "section": "La línea de comandos de Git",
    "text": "La línea de comandos de Git\nExisten diferentes interfaces gráficas para Git, incluyendo GitHub Desktop. Muchos editores de programación, como Microsoft Visual Studio Code, también tienen una interfaz para Git. Todos funcionan de forma diferente y tienen distintas limitaciones. Ninguno de ellos implementa todas las funcionalidades de Git.\nLos ejercicios de este módulo utilizan la línea de comandos de Git, en concreto, comandos de Git ejecutados en Azure Cloud Shell. Sin embargo, la interfaz de línea de comandos de Git funciona igual, independientemente del sistema operativo que estés utilizando. Además, la línea de comandos te permite aprovechar toda la funcionalidad de Git. Los desarrolladores que sólo ven Git a través de una interfaz gráfica de usuario a veces se encuentran con mensajes de error que no pueden resolver, y tienen que recurrir a la línea de comandos para ponerse en marcha de nuevo."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#git-y-github",
    "href": "posts/2024-11-18-intro_git/index.html#git-y-github",
    "title": "Introducción a Git",
    "section": "Git y GitHub",
    "text": "Git y GitHub\nA medida que trabajas con Git, puede que te preguntes sobre las diferencias entre las funciones que ofrece y las que ofrece GitHub.\nComo se mencionó anteriormente, Git es un sistema de control de versiones distribuido (DVCS) que múltiples desarrolladores y otros colaboradores pueden utilizar para trabajar en un proyecto. Proporciona una manera de trabajar con una o más ramas locales y luego enviarlas a un repositorio remoto.\nGitHub es una plataforma en la nube que utiliza Git como tecnología central. GitHub simplifica el proceso de colaboración en proyectos y proporciona un sitio web, más herramientas de línea de comandos y un flujo general que los desarrolladores y usuarios pueden utilizar para trabajar juntos. GitHub actúa como el repositorio remoto mencionado anteriormente.\nEntre las principales características que ofrece GitHub se incluyen:\n\nTemas\nDebates\nPull requests\nNotificaciones\nEtiquetas\nAcciones\nForks\nProyectos\n\nPara obtener más información sobre GitHub, consulta el módulo Introducción a GitHub de Microsoft Learn o la documentación de ayuda Introducción a GitHub.\nEl siguiente paso es probar Git por ti mismo."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#ejercicio---prueba-git",
    "href": "posts/2024-11-18-intro_git/index.html#ejercicio---prueba-git",
    "title": "Introducción a Git",
    "section": "Ejercicio - Prueba Git",
    "text": "Ejercicio - Prueba Git\nAntes de que puedas crear tu primer repositorio, debes asegurarte de que Git está instalado y configurado. Git viene preinstalado con Azure Cloud Shell, por lo que podemos utilizar Git en Cloud Shell a la derecha.\n\nConfigurar Git\n\nEn Cloud Shell, para comprobar que Git está instalado, escribe git --version:\n\n\n\nBash\n\ngit --version\n\n\n\n\n\n\n\nTip\n\n\n\nPuede utilizar el botón Copiar para copiar comandos en el portapapeles. Para pegar, haga clic con el botón derecho en una nueva línea del terminal de Cloud Shell y seleccione Pegar, o utilice el atajo de teclado Mayús+Insertar (⌘+V en macOS).\n\n\n\nDebería ver una salida parecida a la de este ejemplo:\n\n\n\nOutput\n\ngit version 2.22.0\n\n\nPara configurar Git, debes definir algunas variables globales: user.name y user.email. Ambas son necesarias para que puedas hacer commits.\nEstablezca su nombre en Cloud Shell con el siguiente comando. Sustituya &lt;NOMBRE_USUARIO&gt; por el nombre de usuario que desee utilizar.\n\n\n\nBash\n\ngit config --global user.name \"&lt;NOMBRE_USUARIO&gt;\"\n\n\nAhora, utilice este comando para crear una variable de configuración user.email, sustituyendo &lt;USER_EMAIL&gt; por su dirección de correo electrónico:\n\n\n\nBash\n\ngit config --global user.email \"&lt;USER_EMAIL&gt;\"\n\n\nEjecute el siguiente comando para comprobar que sus cambios han funcionado:\n\n\n\nBash\n\ngit config --list\n\n\nCompruebe que la salida incluye dos líneas similares a las del ejemplo siguiente. Su nombre y dirección de correo electrónico serán diferentes de los que se muestran en el ejemplo.\n\n\n\nOutput\n\nuser.name=MIUSUARIO\nuser.email=miusuario@protonmail.com"
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#configura-tu-repositorio-git",
    "href": "posts/2024-11-18-intro_git/index.html#configura-tu-repositorio-git",
    "title": "Introducción a Git",
    "section": "Configura tu repositorio Git",
    "text": "Configura tu repositorio Git\nGit funciona comprobando los cambios en los archivos dentro de una carpeta determinada. Crearemos una carpeta para que sirva como nuestro árbol de trabajo (directorio del proyecto) y dejaremos que Git lo sepa, para que pueda empezar a seguir los cambios. Le diremos a Git que empiece a seguir los cambios inicializando un repositorio Git en esa carpeta.\nEmpieza creando una carpeta vacía para tu proyecto, y luego inicializa un repositorio Git dentro de ella.\n\nCrea una carpeta llamada Gatos. Esta carpeta será el directorio del proyecto, también llamado árbol de trabajo. El directorio del proyecto es donde se almacenan todos los archivos relacionados con tu proyecto. En este ejercicio, es donde se almacenan tu sitio web y los archivos que crean el sitio web y su contenido.\n\n\n\nBash\n\nmkdir Cats\n\n\nCambie al directorio del proyecto utilizando el comando cd:\n\n\n\nBash\n\ncd Cats\n\n\nAhora, inicialice su nuevo repositorio y establezca el nombre de la rama por defecto a main:\n\n\n\nBash\n\ngit init --initial-branch=main\n\nO utilice el siguiente comando:\n\n\nBash\n\ngit init -b main\n\nPara versiones anteriores de Git, utiliza estos comandos:\n\n\nBash\n\ngit init\ngit checkout -b main\n\nDespués de ejecutar el comando initialize, deberías ver una salida similar a la de este ejemplo:\n\n\nBash\n\nInitialized empty Git repository in /home/&lt;user&gt;/Cats/.git/\n\nSwitched to a new branch 'main'\n\n\nAhora, usa el comando git status para mostrar el estado del árbol de trabajo:\n\n\n\nBash\n\ngit status\n\nGit responde con esta salida, que indica que main es la rama actual. (También es la única rama.) Hasta aquí, todo bien.\n\n\nBash\n\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)        \n\n\nUtilice un comando ls para mostrar el contenido del árbol de trabajo:\n\n\n\nBash\n\nls -a\n\nConfirme que el directorio contiene un subdirectorio llamado .git. (Usar la opción -a con ls es importante porque Linux normalmente oculta los nombres de archivos y directorios que empiezan con un punto). Esta carpeta es el repositorio deGit -el directorio en el que Git almacena los metadatos y el historial del árbol de trabajo. Normalmente no haces nada con el directorio .git directamente. Git actualiza los metadatos allí a medida que cambia el estado del árbol de trabajo para mantener un registro de lo que ha cambiado en tus archivos. Este directorio no tiene nada que ver contigo, pero es increíblemente importante para Git."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#obtén-ayuda-de-git",
    "href": "posts/2024-11-18-intro_git/index.html#obtén-ayuda-de-git",
    "title": "Introducción a Git",
    "section": "Obtén ayuda de Git",
    "text": "Obtén ayuda de Git\nGit, como la mayoría de las herramientas de línea de comandos, tiene una función de ayuda integrada que puedes utilizar para buscar comandos y palabras clave.\n\nEscribe el siguiente comando para obtener ayuda sobre lo que puedes hacer con Git:\n\n\nBash\n\ngit -help\n\nEl comando muestra la siguiente salida:\n\n\nOutput\n\nusage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]\n       [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]\n       [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]\n       [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]\n       &lt;command&gt; [&lt;args&gt;]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      Clone a repository into a new directory\n   init       Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        Add file contents to the index\n   mv         Move or rename a file, a directory, or a symlink\n   reset      Reset current HEAD to the specified state\n   rm         Remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     Use binary search to find the commit that introduced a bug\n   grep       Print lines matching a pattern\n   log        Show commit logs\n   show       Show various types of objects\n   status     Show the working tree status\n\ngrow, mark and tweak your common history\n   branch     List, create, or delete branches\n   checkout   Switch branches or restore working tree files\n   commit     Record changes to the repository\n   diff       Show changes between commits, commit and working tree, etc\n   merge      Join two or more development histories together\n   rebase     Forward-port local commits to the updated upstream head\n   tag        Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch      Download objects and refs from another repository\n   pull       Fetch from and integrate with another repository or a local branch\n   push       Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help &lt;command&gt;' or 'git help &lt;concept&gt;'\nto read about a specific subcommand or concept."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#comandos-básicos-de-git",
    "href": "posts/2024-11-18-intro_git/index.html#comandos-básicos-de-git",
    "title": "Introducción a Git",
    "section": "Comandos básicos de Git",
    "text": "Comandos básicos de Git\nGit funciona recordando los cambios en tus archivos como si estuviera tomando instantáneas de tu sistema de archivos.\nCubriremos algunos comandos básicos para comenzar a rastrear archivos en su repositorio. Luego, guardaremos nuestra primera «instantánea» para que Git la compare.\n\ngit status\nEl primer comando de Git, y el más utilizado, es git status . Ya lo usaste una vez, en el ejercicio anterior, para comprobar que habías inicializado tu repositorio de Git correctamente.\ngit status muestra el estado del árbol de trabajo (y del área de preparación-pronto hablaremos más sobre el área de preparación). Te permite ver qué cambios están siendo seguidos actualmente por Git, para que puedas decidir si quieres pedir a Git que tome otra instantánea.\n\n\ngit add\ngit add es el comando que usas para decirle a Git que empiece a registrar los cambios en ciertos archivos.\nEl término técnico es preparar estos cambios. Usarás git add para preparar los cambios para una confirmación. Todos los cambios en los archivos que han sido añadidos pero aún no confirmados se almacenan en el área de preparación.\n\n\ngit commit\nDespués de haber preparado algunos cambios para su confirmación, puedes guardar tu trabajo en una instantánea invocando el comando git commit.\nCommit es tanto un verbo como un sustantivo. Tiene esencialmente el mismo significado que cuando confirmas un plan o un cambio en una base de datos. Como verbo, confirmar cambios significa que pones una copia (del archivo, directorio u otra «cosa») en el repositorio como una nueva versión. Como sustantivo, una confirmación es el pequeño fragmento de datos que da una identidad única a los cambios que has confirmado. Los datos que se guardan en una confirmación incluyen el nombre y la dirección de correo electrónico del autor, la fecha, comentarios sobre lo que has hecho (y por qué), una firma digital opcional y el identificador único de la confirmación anterior.\n\n\ngit log\nEl comando git log te permite ver información sobre confirmaciones anteriores. Cada confirmación tiene un mensaje adjunto (un mensaje de confirmación), y el comando git log imprime información sobre las confirmaciones más recientes, como su marca de tiempo, el autor y un mensaje de confirmación. Este comando te ayuda a hacer un seguimiento de lo que has estado haciendo y de los cambios que se han guardado.\n\n\ngit help\nYa has probado el comando git help, pero merece la pena recordártelo. Usa este comando para obtener fácilmente información sobre todos los comandos que has aprendido hasta ahora, y más.\nRecuerda que cada comando tiene su propia página de ayuda. Puedes encontrar estas páginas de ayuda escribiendo git &lt;comando&gt; --help. Por ejemplo, git commit --help muestra una página que te informa sobre el comando git commit y cómo usarlo."
  },
  {
    "objectID": "posts/2024-11-18-intro_git/index.html#resumen",
    "href": "posts/2024-11-18-intro_git/index.html#resumen",
    "title": "Introducción a Git",
    "section": "Resumen",
    "text": "Resumen\n¡Enhorabuena! En este módulo, aprendiste los conceptos básicos del uso de Git.\nAprendiste:\n\nUna visión general de los Sistemas de Control de Versiones (VCS).\nTerminología importante de Git.\nLas diferencias entre Git y GitHub.\nCómo configurar Git.\nAlgunos comandos básicos de Git.\n\nLlegados a este punto, ya sabes lo suficiente sobre Git como para utilizar el control de versiones por ti mismo en un proyecto básico. La colaboración con otros desarrolladores es donde brilla el control de versiones. Echa un vistazo a los otros módulos de esta ruta de aprendizaje para obtener más información sobre el uso de Git con otros."
  },
  {
    "objectID": "actualizado.html",
    "href": "actualizado.html",
    "title": "Primera actualizacion",
    "section": "",
    "text": "Este archivo es para realizar el primer commit luego de clonar el repositorio desde Github a mi equipo local."
  },
  {
    "objectID": "posts/2024-11-18-intro_github/index.html",
    "href": "posts/2024-11-18-intro_github/index.html",
    "title": "Introducción a Github",
    "section": "",
    "text": "GitHub proporciona una plataforma para desarrolladores impulsada por IA para crear, escalar y entregar software seguro. Ya sea para planificar nuevas características, corregir errores o colaborar en los cambios, GitHub es el lugar donde más de 100 millones de desarrolladores de todo el mundo se reúnen para crear cosas y hacerlas aún mejor.\nEn este módulo, aprenderás los conceptos básicos de GitHub y obtendrás una mejor comprensión de sus características fundamentales con un ejercicio práctico, todo dentro de un repositorio de GitHub.\n\n\nEn este módulo:\n\nIdentificar las características fundamentales de GitHub.\nAprenderás sobre la gestión de repositorios.\nComprender el flujo de GitHub, incluyendo ramas, commits y pull requests.\nExplorar las características de colaboración de GitHub mediante la revisión de problemas y discusiones.\nReconocer cómo gestionar tus notificaciones y suscripciones de GitHub."
  },
  {
    "objectID": "posts/2024-11-18-intro_github/index.html#introduccion",
    "href": "posts/2024-11-18-intro_github/index.html#introduccion",
    "title": "Introducción a Github",
    "section": "",
    "text": "GitHub proporciona una plataforma para desarrolladores impulsada por IA para crear, escalar y entregar software seguro. Ya sea para planificar nuevas características, corregir errores o colaborar en los cambios, GitHub es el lugar donde más de 100 millones de desarrolladores de todo el mundo se reúnen para crear cosas y hacerlas aún mejor.\nEn este módulo, aprenderás los conceptos básicos de GitHub y obtendrás una mejor comprensión de sus características fundamentales con un ejercicio práctico, todo dentro de un repositorio de GitHub.\n\n\nEn este módulo:\n\nIdentificar las características fundamentales de GitHub.\nAprenderás sobre la gestión de repositorios.\nComprender el flujo de GitHub, incluyendo ramas, commits y pull requests.\nExplorar las características de colaboración de GitHub mediante la revisión de problemas y discusiones.\nReconocer cómo gestionar tus notificaciones y suscripciones de GitHub."
  },
  {
    "objectID": "posts/2024-11-18-intro_github/index.html#qué-es-github",
    "href": "posts/2024-11-18-intro_github/index.html#qué-es-github",
    "title": "Introducción a Github",
    "section": "¿Qué es GitHub?",
    "text": "¿Qué es GitHub?\nEn esta unidad, revisamos los siguientes objetivos de aprendizaje:\n\nBreve descripción de la plataforma empresarial GitHub.\nCómo crear un repositorio.\nCómo añadir archivos a un repositorio.\nCómo buscar repositorios.\nIntroducción a gists y wikis.\n\n\nGitHub\nEs una plataforma basada en la nube que utiliza Git, un sistema de control de versiones distribuido, en su núcleo. La plataforma GitHub simplifica el proceso de colaboración en proyectos y proporciona un sitio web, herramientas de línea de comandos y un flujo general que permite a los desarrolladores y usuarios trabajar juntos.\nComo hemos aprendido antes, GitHub proporciona una plataforma para desarrolladores impulsada por IA para construir, escalar y entregar software seguro. Vamos a desglosar cada uno de los pilares fundamentales de la plataforma GitHub Enterprise, IA, Colaboración, Productividad, Seguridad y Escala.\n\n\nIA\nLa IA generativa está transformando drásticamente el desarrollo de software en estos momentos. La plataforma GitHub Enterprise está mejorando la colaboración a través de pull requests y issues impulsados por IA, la productividad a través de Copilot, y la seguridad automatizando las comprobaciones de seguridad con mayor rapidez.\n\n\nColaboración\nLa colaboración es el núcleo de todo lo que hace GitHub. Sabemos que una colaboración ineficiente supone una pérdida de tiempo y dinero. Contrarrestamos esto con un conjunto de herramientas que permiten la colaboración sin esfuerzo.\nRepositorios, Issues, Pull Requests y otras herramientas ayudan a que desarrolladores, jefes de proyecto, líderes de operaciones y otras personas de la misma empresa puedan colaborar. Esto les permite trabajar juntos más rápido, reducir los tiempos de aprobación y realizar los envíos con mayor celeridad.\n\n\nProductividad\nLa productividad se acelera con la automatización que proporciona la Plataforma Empresarial GitHub. Con herramientas CI/CD (Integración Continua y Entrega Continua) integradas directamente en el flujo de trabajo, la plataforma ofrece a los usuarios la posibilidad de establecer tareas y olvidarse de ellas, ocupándose de la administración rutinaria y acelerando el trabajo diario. De este modo, los desarrolladores disponen de más tiempo para centrarse en lo más importante: crear soluciones innovadoras.\n\n\nSeguridad\nGitHub se centra en integrar la seguridad directamente en el proceso de desarrollo desde el principio. La plataforma GitHub Enterprise incluye funciones de seguridad nativas y propias que minimizan el riesgo de seguridad con una solución de seguridad integrada. Además, tu código permanece privado dentro de tu organización. Al mismo tiempo, puedes aprovechar la visión general de la seguridad y Dependabot.\nGitHub ha seguido invirtiendo para garantizar que nuestras funciones estén preparadas para la empresa. Microsoft y las industrias altamente reguladas confían en GitHub, y cumplimos con los requisitos de cumplimiento global.\n\n\nEscala\nGitHub es la mayor comunidad de desarrolladores de su clase, con datos en tiempo real sobre más de 100 millones de desarrolladores, más de 330 millones de repositorios e innumerables despliegues. Hemos sido capaces de entender las necesidades cambiantes de los desarrolladores y hacer cambios en nuestro producto para que coincida.\nEsto se ha traducido en una escala increíble que no tiene parangón ni comparación con ninguna otra empresa del planeta. Cada día obtenemos más información de esta impresionante comunidad y hacemos evolucionar la plataforma para satisfacer sus necesidades.\nEn esencia, la Plataforma Empresarial GitHub se centra en la experiencia del desarrollador. Tiene la escala para proporcionar conocimientos que cambian la industria, capacidades de colaboración para la eficiencia transformadora, las herramientas para aumentar la productividad, la seguridad en cada paso, y AI para impulsar todo a nuevas alturas en una sola plataforma integrada.\nAhora vamos a entrar en la columna vertebral de GitHub, los repositorios.\n\n\nIntroducción a los repositorios\nHagamos primero un repaso:\n\n¿Qué es un repositorio?\nCómo crear un repositorio\nAñadir ficheros a un repositorio\nCómo buscar repositorios\nIntroducción a gists, wikis y páginas de GitHub\n\n\n¿Qué es un repositorio?\nUn repositorio contiene todos los archivos de tu proyecto y el historial de revisiones de cada archivo. Es una de las partes esenciales que te ayuda a colaborar con la gente. Puedes utilizar repositorios para gestionar tu trabajo, realizar un seguimiento de los cambios, almacenar el historial de revisiones y trabajar con otras personas. Antes de profundizar demasiado, empecemos por cómo crear un repositorio.\n\n\n¿Cómo crear un repositorio?\nPuedes crear un nuevo repositorio en tu cuenta personal o en cualquier organización donde tengas permisos suficientes.\nVamos a abordar la creación de un repositorio desde github.com.\n\nEn la esquina superior derecha de cualquier página, utilice el menú desplegable y seleccione New repository.\n\n\n\n\nUtilice el menú desplegable Owner para seleccionar la cuenta que desea que sea la propietaria del repositorio.\n\n\n\n\nEscriba un nombre para su repositorio y una descripción opcional.Escriba un nombre para su repositorio y una descripción opcional.\n\n\n\n\nElija una visibilidad de repositorio.\n\nLos repositorios públicos son accesibles a todo el mundo en Internet.\nLos repositorios privados sólo son accesibles para ti, para las personas con las que compartes explícitamente el acceso y, para los repositorios de organizaciones, para ciertos miembros de la organización.\n\nSeleccione Crear repositorio y ¡enhorabuena! ¡Acaba de crear un repositorio!\n\n\nA continuación, vamos a ver cómo añadir ficheros a tu repositorio.\n\n\n¿Cómo añadir un archivo a tu repositorio?\nLos archivos en GitHub pueden hacer un puñado de cosas, pero el propósito principal de los archivos es almacenar datos e información sobre tu proyecto. Vale la pena saber que para añadir un archivo a un repositorio primero debes tener un acceso mínimo de Escritura dentro del repositorio al que quieres añadir un archivo.\nRepasemos cómo añadir un archivo a tu repositorio.\n\nEn GitHub.com, navega a la página principal del repositorio.\nEn tu repositorio, navega hasta la carpeta donde quieres crear un archivo seleccionando el enlace crear un nuevo archivo o subiendo un archivo existente.\n\nEn el campo de nombre de archivo, escriba el nombre y la extensión del archivo. Para crear subdirectorios, escriba el separador de directorios /.\n\nEn el cuadro de texto Contenido del archivo, escriba el contenido del archivo.\n\nPara revisar el nuevo contenido, encima del contenido del archivo, seleccione Vista previa.\nSeleccione Confirmar cambios.\n\nEn el campo Mensaje de confirmación, escriba un mensaje de confirmación breve y significativo que describa el cambio realizado en el archivo. Puedes atribuir la confirmación a más de un autor en el mensaje de confirmación.\n\nAsi se puede ver luego de realizar commit:\n\nVamos a crear otro archivo.\n\nDebajo de los campos de mensaje de confirmación, decida si desea añadir su confirmación a la rama actual o a una nueva rama. Si su rama actual es la rama por defecto, debe elegir crear una nueva rama para su confirmación y, a continuación, crear una solicitud de extracción.\n\n\n\n\nSeleccione Confirmar cambios o Proponer cambios.\n\n\nEnhorabuena, ¡acaba de crear un nuevo fichero en su repositorio! También has creado una nueva rama y hecho un commit.\nAntes de revisar ramas y commits en la siguiente unidad, vamos a revisar rápidamente gists, wikis y páginas de GitHub porque son similares a los repositorios.\n\n\n¿Qué son las gists?\nAhora que ya conocemos bien los repositorios, podemos revisar las gists. Al igual que los repositorios, las gists son una forma simplificada de compartir fragmentos de código con los demás.\nCada gist es un repositorio Git, que puedes bifurcar y clonar y que puede ser público o privado. Las gists públicas se muestran públicamente y la gente puede consultar las nuevas a medida que se crean. En las gists públicas también se pueden realizar búsquedas. Por el contrario, las gists privadas no permiten búsquedas, pero no son totalmente privadas. Si envías la URL de una lista secreta a un amigo, éste podrá verla.\nPara obtener más información sobre gists, consulte el artículo vinculado en nuestra sección de Recursos al final de este módulo titulado Creación de Gists.\n\n\n¿Qué son las wikis?\nCada repositorio en GitHub.com viene equipado con una sección para alojar documentación, llamada wiki. Puedes utilizar el wiki de tu repositorio para compartir contenido extenso sobre tu proyecto, como por ejemplo ¿cómo utilizarlo?, ¿cómo lo diseñaste?, o sus principios básicos. Mientras que un archivo README dice rápidamente lo que su proyecto puede hacer, puede utilizar un wiki para proporcionar documentación adicional.\nVale la pena recordar que si su repositorio es privado, sólo las personas que tienen al menos acceso de lectura a su repositorio tendrán acceso a su wiki."
  },
  {
    "objectID": "posts/2024-11-18-intro_github/index.html#componentes-del-flujo-de-github",
    "href": "posts/2024-11-18-intro_github/index.html#componentes-del-flujo-de-github",
    "title": "Introducción a Github",
    "section": "Componentes del flujo de GitHub",
    "text": "Componentes del flujo de GitHub\nEn esta unidad, revisaremos los siguientes componentes del flujo de GitHub:\n\nRamas\nCommits\nSolicitudes de Pull\nEl flujo de GitHub\n\n\n¿Qué son las ramas?\nEn la última sección, hemos creado un nuevo archivo y una nueva rama en tus repositorios.\nLas ramas son una parte esencial de la experiencia GitHub, ya que son donde podemos hacer cambios sin afectar a todo el proyecto en el que estamos trabajando.\nTu rama es un lugar seguro para experimentar con nuevas características o correcciones. Si cometes un error, puedes revertir tus cambios o empujar más cambios para corregir el error. Tus cambios no se actualizarán en la rama por defecto hasta que fusiones tu rama.\n\nNota\nAlternativamente, puedes crear una nueva rama y comprobarla usando git en un terminal. El comando sería git checkout -b nombreNuevaRama\n\n\n\n¿Qué son los commits?\nEn la unidad anterior, añadiste un nuevo archivo al repositorio enviando una confirmación. Repasemos brevemente qué son las confirmaciones.\nUna confirmación es un cambio en uno o más ficheros de una rama. Cada vez que se crea una confirmación, se le asigna un ID único y se realiza un seguimiento junto con la hora y el contribuidor. Los commits proporcionan una pista de auditoría clara para cualquiera que revise el historial de un archivo o elemento vinculado, como una incidencia (issue) o pull request.\n\nDentro de un repositorio de Git, un archivo puede existir en varios estados válidos a medida que pasa por el proceso de control de versiones. Los estados primarios de un archivo en un repositorio de Git son No rastreado y Rastreado.\nNo rastreado: El estado inicial de un archivo cuando no forma parte aún del repositorio de Git. Git no está al tanto de su existencia.\nRastreado: Un archivo rastreado es uno que Git está monitoreando activamente. Puede estar en uno de los siguientes subestados:\n\nNo modificado: El archivo es rastreado, pero no ha sido modificado desde el último commit.\nModificado: El archivo ha sido cambiado desde el último commit, pero estos cambios no están aún en la área de staging para el próximo commit.\nStaged: El archivo ha sido modificado y los cambios han sido agregados al área de staging (también conocida como el índice). Estos cambios están listos para ser comprometidos.\nCommited: El archivo se encuentra en la base de datos del repositorio. Representa la versión más reciente comprometida del archivo.\n\nEstos estados y subestados son importantes para colaborar con tu equipo y saber dónde se encuentra cada y cada commit en el proceso de tu proyecto. Ahora, pasemos a las solicitudes de extracción.\n\n\n¿Qué son las solicitudes de extracción?\nLa solicitud de extracción es el mecanismo utilizado para indicar que los commits de una rama están listos para ser fusionados en otra rama.\nEl miembro del equipo que envía la solicitud de extracción pide a uno o más revisores que verifiquen el código y aprueben la fusión. Estos revisores tienen la oportunidad de comentar sobre los cambios, agregar sus propios o utilizar la solicitud de extracción misma para discusiones adicionales.\nUna vez aprobados los cambios (si es necesario), la rama de origen (rama de comparación) se fusiona en la rama base.\n\nLuego de oprimir Crear pull request nos queda la siguiente pantalla:\n\nQuiere decir que alguien (para este caso nosotros mismos) quiere fusionar a la rama principal (main) un commit que proviene de la rama cchiquitovalencia-patch-1.\n\nNos solicita confirmacion de la siguiente forma:\n\nFinalmente llegamos a:\n\nEn este punto, luego de haber realizado los cambios en la rama que creamos (no la principal “main”) y confirmado que queremos actualizarlos dentro de la rama original, Github nos dice que es seguro eliminar esa rama, ya cumplio con su cometido.\nAntes de hacerlo vamos a nuestro repositorio para ver el estado:\n\nAqui esta la historia de lo que hemos realizado en cuanto a los commits:\n\nAhora que conocemos todos los ingredientes, revisemos el flujo de GitHub.\n\n\nEl flujo de GitHub\n\nEl flujo de GitHub se puede definir como un flujo de trabajo ligero que permite experimentar de manera segura. Puedes probar nuevas ideas y colaborar con tu equipo utilizando ramas, solicitudes de extracción y fusión.\nAhora que conocemos los fundamentos de GitHub, podemos recorrer el flujo de GitHub y sus componentes.\nComienza creando una rama para que los cambios, características y correcciones que creas no afecten la rama principal. A continuación, haz tus cambios. Recomendamos desplegar cambios en tu rama de características antes de fusionar en la rama principal. Al hacerlo, aseguras que los cambios sean válidos en un entorno de producción. Ahora, crea una solicitud de extracción para pedir retroalimentación a tus colaboradores. La revisión de solicitudes de extracción es tan valiosa que algunos repositorios requieren una revisión aprobatoria antes de que las solicitudes de extracción puedan ser fusionadas. Luego, revisa y aplica la retroalimentación de tus colaboradores. Una vez que te sientas satisfecho con tus cambios, es hora de obtener aprobación para tu solicitud de extracción y fusionarla en la rama principal. Finalmente, puedes eliminar tu rama. Eliminar tu rama indica que tu trabajo en la rama está completo y previene que tú o otros utilicen ramas antiguas por error.\n¡Eso es todo! Has completado un ciclo de flujo de GitHub.\nVamos a pasar al siguiente apartado, donde cubriremos las diferencias entre problemas (issues) y discusiones (discussions)."
  },
  {
    "objectID": "posts/2024-11-18-intro_github/index.html#github-es-una-plataforma-colaborativa",
    "href": "posts/2024-11-18-intro_github/index.html#github-es-una-plataforma-colaborativa",
    "title": "Introducción a Github",
    "section": "GitHub es una plataforma colaborativa",
    "text": "GitHub es una plataforma colaborativa\nLa colaboración está en el núcleo de todo lo que hace GitHub. En el primer unidad del módulo, aprendimos que los repositorios ayudan a organizar tu proyecto y sus archivos. En la última unidad, aprendimos sobre solicitudes de extracción, que es una forma de seguir el progreso de los cambios realizados en tu proyecto.\nEn este unidad, estamos aprendiendo sobre problemas y discusiones. Estos son dos piezas más que contribuyen a la naturaleza colaborativa de la plataforma de GitHub Enterprise.\n\nProblemas (issues)\nLos problemas de GitHub se crearon para rastrear ideas, retroalimentación, tareas o bugs para el trabajo en GitHub. Los problemas pueden crearse de varias maneras, por lo que puedes elegir el método más conveniente para tu flujo de trabajo.\nPara este recorrido, vamos a cubrir cómo crear un problema desde un repositorio. Pero los problemas también pueden crearse desde:\n\nUn elemento en una lista de tareas.\nUna nota en un proyecto.\nUn comentario en un problema o solicitud de extracción.\nUna línea específica de código.\nUna consulta URL.\n\n\n\nCrear un problema desde un repositorio\n\nEn GitHub.com, navega hasta la página principal del repositorio.\nDebajo de tu nombre de repositorio, selecciona Problemas.\n\n\n\nSelecciona Nuevo problema.\nSi tu repositorio utiliza plantillas de problemas, a continuación de la tipo de problema que deseas abrir, selecciona Iniciar. Si el tipo de problema que deseas abrir no se incluye en las opciones disponibles, selecciona Abrir un problema en blanco. Si no se utiliza plantillas, omita este paso.\nEn el campo Agregar un título, ingresa un título para tu problema.\nEn el campo Agregar una descripción, escribe una descripción de tu problema.\n\nSi eres un mantenedor del proyecto, puedes asignar el problema a alguien, agregarlo a una pizarra de proyecto, asociarlo con un hito o aplicar una etiqueta.\nCuando estés listo, selecciona Enviar nuevo problema.\n\n\nAlgunas conversaciones son más adecuadas para GitHub Discusiones. Puedes utilizar GitHub Discusiones para preguntar y responder preguntas, compartir información, hacer anuncios y conducir o participar en conversaciones sobre un proyecto.\nEn la próxima sección, revisaremos Discusiones y cómo utilizar mejor el recurso.\n\n\nDiscusiones\nLas discusiones son para conversaciones que necesitan ser accesibles para todos y no están relacionadas con el código. Las discusiones permiten conversaciones fluidas y abiertas en un foro público.\nEn esta sección, vamos a cubrir:\n\nHabilitar una discusión en tu repositorio.\nCrear una nueva discusión y categorías de discusión.\n\nVamos a profundizar en habilitar una discusión en tu repositorio.\n\n\nHabilitar una discusión en tu repositorio\nLos propietarios de repositorios y las personas con acceso de escritura pueden habilitar GitHub Discusiones para una comunidad en sus repositorios públicos y privados. La visibilidad de una discusión se hereda del repositorio en el que se crea la discusión.\nCuando habilitas GitHub Discusiones por primera vez, te invitan a configurar un post de bienvenida.\n\nEn GitHub.com, navega hasta la página principal del repositorio.\nDebajo de tu nombre de repositorio, selecciona Configuración.\n\nDesplaza el cursor hacia abajo hasta la sección Características y selecciona Configurar discusiones.\n\nEn Iniciar una nueva discusión, edita el plantilla para alinear con los recursos y el tono que deseas establecer para tu comunidad.\n\nSelecciona Iniciar discusión.\n\nAhora estás listo para crear una nueva discusión.\n\n\n\n\n\nCrear una nueva discusión\nCualquier usuario autenticado que pueda ver el repositorio puede crear una discusión en ese repositorio. De manera similar, ya que las discusiones de organización se basan en un repositorio fuente, cualquier usuario autenticado que pueda ver el repositorio fuente puede crear una discusión en esa organización.\n\nEn GitHub.com, navega hasta la página principal del repositorio o rganización donde deseas iniciar una discusión.\nDebajo de tu nombre de repositorio o organización, selecciona Discusiones.\nEn el lado derecho de la página, selecciona Nueva discusión.\nSelecciona una categoría de discusión al seleccionar Get started. Todos los problemas deben crearse en una categoría. Para las discusiones de repositorios, los mantenidos o administradores del repositorio definen las categorías de discusiones en ese repositorio.\n\n\nCada categoría debe tener un nombre único, emparejamiento de emojis y una descripción detallada que explique su propósito. Las categorías ayudan a los mantenidos a organizar cómo se archivan las conversaciones. Están personalizables para ayudar a distinguir categorías que son Q&A o conversaciones más abiertas.\n\nLa siguiente tabla muestra las categorías predeterminadas para discusiones y su propósito.\n\nEso cubre un poco sobre cómo GitHub inspira la colaboración. Ahora, vamos a movernos a cómo puedes administrar notificaciones, suscribirte a hilo y empezar con GitHub Pages."
  },
  {
    "objectID": "posts/2024-11-18-intro_github/index.html#gestión-de-la-plataforma-de-github",
    "href": "posts/2024-11-18-intro_github/index.html#gestión-de-la-plataforma-de-github",
    "title": "Introducción a Github",
    "section": "Gestión de la plataforma de GitHub",
    "text": "Gestión de la plataforma de GitHub\nAhora que conoces los fundamentos de la plataforma de GitHub, vamos a explorar algunas estrategias de gestión de la plataforma.\nEn esta unidad, cubriremos:\n\nAdministrar notificaciones y suscripciones.\nSuscribirte a hilos y encontrar hilos donde te mencionan.\nPublicar tu proyecto o organización en GitHub Pages.\n\n\nGestión de notificaciones y suscripciones\nPuedes elegir recibir actualizaciones continuas sobre actividad específica en GitHub.com a través de una suscripción. Las notificaciones son las actualizaciones que recibes sobre actividad específica a la que te has suscrito.\n\nOpciones de suscripción\nPuedes elegir suscribirte a notificaciones para:\n\nUna conversación en un problema específico, solicitud de extracción o gist.\nActividad de CI, como el estado de flujos de trabajo en repositorios configurados con GitHub Actions.\nProblemas, solicitudes de extracción, lanzamientos, alertas de seguridad o discusiones (si se habilitan) en un repositorio.\nTodas las actividades en un repositorio.\n\nEn algunos casos, te suscribirás automáticamente a conversaciones en GitHub. Ejemplos incluyen abrir una solicitud de extracción o problema, comentar en un hilo o ser asignado a un problema o solicitud de extracción.\nSi ya no estás interesado en una conversación, puedes desuscribirte, desatender o personalizar los tipos de notificaciones que recibirás en el futuro.\nSi alguna vez estás interesado en problemas que mencionan a un usuario específico, puedes utilizar menciones: como el cuadro para encontrar esos problemas específicos.\n\n\n\n¿Qué son GitHub Pages?\nPara completar nuestro viaje por GitHub, vamos a abordar GitHub Pages. Puedes utilizar GitHub Pages para publicar y alojar un sitio web sobre ti mismo, tu organización o tu proyecto directamente desde un repositorio en GitHub.com.\nGitHub Pages es un servicio de alojamiento de sitios web estáticos que toma archivos HTML, CSS y JavaScript directamente desde un repositorio en GitHub. Opcionalmente, puedes ejecutar los archivos a través de un proceso de compilación y publicar un sitio web. Edita y envía tus cambios, y tu proyecto estará disponible para el público de manera organizada visualmente."
  },
  {
    "objectID": "posts/2024-11-18-ejemplo_usarGithub/index.html",
    "href": "posts/2024-11-18-ejemplo_usarGithub/index.html",
    "title": "Retomando labores",
    "section": "",
    "text": "Tengo una página en Github, la había creado en el 2023 en un equipo diferente al que ahora estoy usando, la última vez que actualicé la página fue en octubre 2024:\n\nEstaba entusiasmado por retomar con las publicaciones de lo que puedo compartir de mis experiencias en programación (claramente no soy un experto) para optimizar los procesos. Pero todo lo había creado en un computador que ahora no es mio.\nPor cosas de la vida ahora estoy usando un computador muy antiguo, ni siquiera soportaba Windows 7, asi que, leyendo un poco, ahora esta corriendo Linux Mint. Aquí las especificaciones:\n\n\nBash\n\nArchitecture:                       x86_64\nCPU op-mode(s):                     32-bit, 64-bit\nByte Order:                         Little Endian\nAddress sizes:                      36 bits physical, 48 bits virtual\nCPU(s):                             2\nOn-line CPU(s) list:                0,1\nThread(s) per core:                 1\nCore(s) per socket:                 2\nSocket(s):                          1\nNUMA node(s):                       1\nVendor ID:                          AuthenticAMD\nCPU family:                         20\nModel:                              1\nModel name:                         AMD E-350 Processor\nStepping:                           0\nCPU MHz:                            1595.989\nCPU max MHz:                        1600,0000\nCPU min MHz:                        800,0000\nBogoMIPS:                           3191.98\nVirtualization:                     AMD-V\nL1d cache:                          64 KiB\nL1i cache:                          64 KiB\nL2 cache:                           1 MiB\nNUMA node0 CPU(s):                  0,1\n\nComo ven, antiguo. Pero funciona!\nMi tarea ahora es lograr configurar el flujo de trabajo que tenía en ese entonces en mi “nuevo” equipo.\nVoy a la carpeta Documents, creo una nueva llamada repo_cchiquitovalencia.\nPasos:\n\nEn GitHub, navegué hasta la página principal del repositorio.\nEncima de la lista de archivos, hice clic en Código.\n\nCopié la dirección URL del repositorio. Para clonar el repositorio con HTTPS, en “HTTPS”, hice clic en el ícono.\nAbrí una Terminal.\nCambié el directorio de trabajo actual a la ubicación en donde quería clonar el directorio. En mi caso:\n\n\nBash\n\ncd Documents/repo_cchiquitovalencia\n\nEscribí git clone y pegué la dirección URL que he copiado antes.\n\n\nBash\n\ngit clone https://github.com/cchiquitovalencia/cchiquitovalencia.github.io.git\n\nPresioné Entrar para crear el clon local.\n\n\nBash\n\nClonando en 'cchiquitovalencia.github.io'...\nremote: Enumerating objects: 406, done.\nremote: Counting objects: 100% (406/406), done.\nremote: Compressing objects: 100% (249/249), done.\nremote: Total 406 (delta 210), reused 304 (delta 116), pack-reused 0 (from 0)\nRecibiendo objetos: 100% (406/406), 2.75 MiB | 3.32 MiB/s, listo.\nResolviendo deltas: 100% (210/210), listo.\n\n\nListo! En este momento los archivos estan en mi equipo local. Pero eso es todo, no estan en seguimiento. Entonces:\n\n\nBash\n\n~/Documents/repo_cchiquitovalencia$ git init\n\n\n\nOutput\n\nInicializado repositorio Git vacío en /home/cchvcpcj/Documents/repo_cchiquitovalencia/.git/\n\nRevisemos el estado:\n\n\nBash\n\n~/Documents/repo_cchiquitovalencia$ git status\n\n\n\nOutput\n\nEn la rama master\n\nNo hay commits todavía\n\nArchivos sin seguimiento:\n  (usa \"git add &lt;archivo&gt;...\" para incluirlo a lo que se será confirmado)\n\n    cchiquitovalencia.github.io/\n\nno hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa \"git add\" para hacerles seguimiento)\n\nHago lo que me dice:\n\n\nBash\n\n~/Documents/repo_cchiquitovalencia$ git add cchiquitovalencia.github.io/\n\n\n\nOutput\n\nEn la rama master\n\nNo hay commits todavía\n\nCambios a ser confirmados:\n  (usa \"git rm --cached &lt;archivo&gt;...\" para sacar del área de stage)\n\n    nuevo archivo:  cchiquitovalencia.github.io/.gitignore\n    nuevo archivo:  cchiquitovalencia.github.io/.nojekyll\n...\n    nuevo archivo:  cchiquitovalencia.github.io/posts/_metadata.yml\n    nuevo archivo:  cchiquitovalencia.github.io/resources.qmd\n    nuevo archivo:  cchiquitovalencia.github.io/styles.css\n    nuevo archivo:  cchiquitovalencia.github.io/styles.scss\n\nAhora, mientras escribo este post en un documento de Quarto dentro de una sesion de Rstudio, puedo abrir otra para revisar que todo este en orden: poder hacer commits y push desde local a Github.\n\nBueno, aquí mi primer problema:\n\nEl formato ssh no tiene soporte? Como siempre, cuando hay problemas, vamos a stack overflow: “push git unsupported gpg.format ssh”, unos blogs más tarde, la respuesta fue:\n\nEn este momento, me acordé que en la manana estaba trabajando en otro post sobre Git, y revise la version:\n\nEntonces le hice caso a Martin Thoma. Miremos lo que tengo:\n\n\nBash\n\ngit config --list\n\n\n\nOutput\n\ncredential.helper=cache\ncredential.helper=\ncredential.helper=/usr/local/share/gcm-core/git-credential-manager-core\ncredential.credentialstore=gpg\nuser.name=cchiquitovalencia\nuser.email=cchiquito.valencia@pm.me\nuser.signingkey=/home/cchvcpcj/.ssh/id_ed25519.pub\ncredential.https://dev.azure.com.usehttppath=true\ncommit.gpgsign=false\ngpg.format=ssh\n\nLuego de modificar el .gitconfig\n\nAhora, PUSH!: y me solicita un PASSPHRASE.\n\nClaro que algo falló, no me acuerdo del passphrase! Luego de investigar un poco sobre como recuperar mi passphrase: puedes revisar en donde esta disponible tu llave y puedes crear el certificado de revocacion de tu llave publica, pero necesitas acordarte del passphrase!\nY luego segui revisando otro poco mas, y como no entendi nada aqui, pues me asegure de no olvidar nunca mas el passphrase.\nAl final lo unico que entendi fue que debia generar otra llave:\n\nDescargué e instalé las herramientas de línea de comandos GPG para mi sistema operativo.\nPuedes confirmar si tienes una version instalada:\n\n\nBash\n\ngpg --version\n\n\n\nOutput\n\ngpg (GnuPG) 2.2.19\nlibgcrypt 1.8.5\nCopyright (C) 2019 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nHome: /home/cchvcpcj/.gnupg\nSupported algorithms:\nPubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\nCipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\n        CAMELLIA128, CAMELLIA192, CAMELLIA256\nHash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\nCompression: Uncompressed, ZIP, ZLIB, BZIP2\n\nAbrí una Terminal.\nGeneré un par de claves GPG. Dado que existen varias versiones de GPG, es posible que debas consultar la página de manual correspondiente para encontrar el comando de generación de claves adecuado.\n\n\nBash\n\ngpg --full-generate-key\n\n\n\nOutput\n\ngpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nPlease select what kind of key you want:\n   (1) RSA and RSA (default)\n   (2) DSA and Elgamal\n   (3) DSA (sign only)\n   (4) RSA (sign only)\n  (14) Existing key from card\nYour selection? 1\n\nRSA keys may be between 1024 and 4096 bits long.\nWhat keysize do you want? (3072) 4096\n\nPlease specify how long the key should be valid.\n         0 = key does not expire\n      &lt;n&gt;  = key expires in n days\n      &lt;n&gt;w = key expires in n weeks\n      &lt;n&gt;m = key expires in n months\n      &lt;n&gt;y = key expires in n years\nKey is valid for? (0) 0\nKey does not expire at all\nIs this correct? (y/N) y\n\n\nFinalmente genero otra llave más porque la que tenia había expirado. Qué tal que hubiera buscado maneras de aligerar la búsqueda de mi llave?, será que al final tendría que haber buscado la manera de ponerla a funcionar luego de expirar?\n\n\nOutput\n\nsec   rsa4096/BE0A7004D70A24F0 2022-03-23 [SC]\n      8D8EDF6C11646AB64D276070BE0A7004D70A24F0\nuid                 [ultimate] cchiquitovalencia (Key to) &lt;cchiquito.valencia@pm.me&gt;\n\nsec   rsa4096/D0A5DB1B2962C681 2024-11-15 [SC]\n      6DA68EDA9FE612269D802528D0A5DB1B2962C681\nuid                 [ultimate] cchiquitovalencia (Acceso para Github) &lt;cchiquito.valencia@pm.me&gt;\nssb   rsa4096/F4AE44B3682F30AE 2024-11-15 [E]\n\nEs necesario registrar la llave en Github, vamos a Configuración:\n\nLa zona de acceso\n\ny nueva llave:\n\nY digitamos título y PUBLIC KEY BLOCK:\n\nPara obtener la llave completa que debemos registrar, ejecutar en la Terminal:\n\n\nBash\n\ngpg --armor --export D0A5DB1B2962C681\n\nCambiando el Key ID para cada llave generada. Ahora tengo esto:\n\nAhora si, ya:\n\nCloné el repositorio que se encuentra alojado en Github a mi equipo local.\nInicié el seguimiento con Git en mi control de versiones al proyecto local.\nActualicé mi version de Git para tener acceso son SSH.\nCreé una llave pública nueva, porque no recordaba que la anterior expiró.\nRegistré la llave nueva a Github para realizar PUSH desde lo local.\n\nEntonces creo un archivo para realizar la prueba, se llama “actualizado.qmd” y contiene lo siguiente.\n\nFinalmente guardo el archivo y le doy commit:\n\nAhora, la hora de la verdad: PUSH! No sin antes decirle a Git que cambie la llave porque al principio teniamos: user.signingkey=/home/cchvcpcj/.ssh/id_ed25519.pub\nEn la Terminal:\n\n\nBash\n\ngit config --global user.signingkey D0A5DB1B2962C681\n\nPUSH!!!!\nPues nada pasó a Github. De alguna manera me pide el usuario, y le digo cchiquitovalencia, luego me pide clave, pero de un correo que no tengo registado en Github. Solo tengo registrado cchiquito.valencia@pm.me, entonces pienso que algo tiene que ver con el “credential.manager”:\n\n\nBash\n\ngit-credential-manager configure\n\n\n\nOutput\n\nbash: git-credential-manager: command not found\n\nPues a instalarlo se dijo:\n\nY así:\n\n\nBash\n\nsudo dpkg -i /home/cchvcpcj/Downloads/gcm-linux_amd64.2.6.0.deb\n\n\n\nOutput\n\nSeleccionando el paquete gcm previamente no seleccionado.\n(Leyendo la base de datos ... 419408 ficheros o directorios instalados actualmente.)\nPreparando para desempaquetar .../gcm-linux_amd64.2.6.0.deb ...\nDesempaquetando gcm (2.6.0) ...\nConfigurando gcm (2.6.0) ...\n\nAhora sí:\n\n\nBash\n\ngit-credential-manager configure\n\n\n\nOutput\n\nConfiguring component 'Git Credential Manager'...\nConfiguring component 'Azure Repos provider'...\n\nReviso la configuracion:\n\n\nBash\n\ngit config --list\n\n\n\nOutput\n\ncredential.helper=cache\ncredential.helper=\ncredential.helper=/usr/local/share/gcm-core/git-credential-manager-core\ncredential.credentialstore=gpg\ncredential.cacheoptions=--timeout 300\ncredential.helper=\ncredential.helper=/usr/local/bin/git-credential-manager\nuser.name=cchiquitovalencia\nuser.email=cchiquito.valencia@pm.me\nuser.signingkey=D0A5DB1B2962C681\ncredential.https://dev.azure.com.usehttppath=true\ncommit.gpgsign=true\n\nAlgunas verificaciones mas tarde, un passphrase muy bien recordado (no lo olvidaré, y me aseguré muy bien de no volver a hacerlo) y finalmente:\n\ny PUSH!!!!!!!!!!\n\n“De nuevo en el negocio.”\n\n\n\nCitationBibTeX citation:@online{chiquito_valencia2024,\n  author = {Chiquito Valencia, Cristian},\n  title = {Retomando Labores},\n  date = {2024-11-18},\n  url = {https://cchiquitovalencia.github.io/posts/2028-11-18-ejemplo_usarGithub/},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nChiquito Valencia, Cristian. 2024. “Retomando Labores.”\nNovember 18, 2024. https://cchiquitovalencia.github.io/posts/2028-11-18-ejemplo_usarGithub/."
  },
  {
    "objectID": "posts/2024-11-18-ejemplo_usarGithub/ejemplo_usarGithub.html",
    "href": "posts/2024-11-18-ejemplo_usarGithub/ejemplo_usarGithub.html",
    "title": "Retomando labores",
    "section": "",
    "text": "Tengo una página en Github, la había creado en el 2023 en un equipo diferente al que ahora estoy usando, la ultima vez que actualice la pagina fue en octubre 2024:\n\nEstaba entusiasmado por retomar con las publicaciones de lo que puedo compartir de mis experiencias en programación (claramente no soy un experto) para optimizar los procesos. Pero todo lo había creado en un computador que ahora no es mio.\nPor cosas de la vida ahora estoy usando un computador muy antiguo, ni siquiera soportaba Windows 7, asi que, leyendo un poco, ahora esta corriendo Linux Mint. Aqui las especificaciones:\n\n\nBash\n\nArchitecture:                       x86_64\nCPU op-mode(s):                     32-bit, 64-bit\nByte Order:                         Little Endian\nAddress sizes:                      36 bits physical, 48 bits virtual\nCPU(s):                             2\nOn-line CPU(s) list:                0,1\nThread(s) per core:                 1\nCore(s) per socket:                 2\nSocket(s):                          1\nNUMA node(s):                       1\nVendor ID:                          AuthenticAMD\nCPU family:                         20\nModel:                              1\nModel name:                         AMD E-350 Processor\nStepping:                           0\nCPU MHz:                            1595.989\nCPU max MHz:                        1600,0000\nCPU min MHz:                        800,0000\nBogoMIPS:                           3191.98\nVirtualization:                     AMD-V\nL1d cache:                          64 KiB\nL1i cache:                          64 KiB\nL2 cache:                           1 MiB\nNUMA node0 CPU(s):                  0,1\n\nComo ven, antiguo. Pero funciona!\nMi tarea ahora es lograr configurar el flujo de trabajo que tenia en ese entonces en mi “nuevo” equipo.\nVoy a la carpeta Documentos, creo una nueva llamada repo_cchiquitovalencia.\nPasos:\n\nEn GitHub, navegué hasta la página principal del repositorio.\nEncima de la lista de archivos, hice clic en Código.\n\nCopié la dirección URL del repositorio. Para clonar el repositorio con HTTPS, en “HTTPS”, hice clic en el ícono.\nAbrí una Terminal.\nCambié el directorio de trabajo actual a la ubicación en donde quería clonar el directorio. En mi caso:\n\n\nBash\n\ncd Documents/repo_cchiquitovalencia\n\nEscribí git clone y pegué la dirección URL que he copiado antes.\n\n\nBash\n\ngit clone https://github.com/cchiquitovalencia/cchiquitovalencia.github.io.git\n\nPresioné Entrar para crear el clon local.\n\n\nBash\n\nClonando en 'cchiquitovalencia.github.io'...\nremote: Enumerating objects: 406, done.\nremote: Counting objects: 100% (406/406), done.\nremote: Compressing objects: 100% (249/249), done.\nremote: Total 406 (delta 210), reused 304 (delta 116), pack-reused 0 (from 0)\nRecibiendo objetos: 100% (406/406), 2.75 MiB | 3.32 MiB/s, listo.\nResolviendo deltas: 100% (210/210), listo.\n\n\nListo! En este momento los archivos estan en mi equipo local. Pero eso es todo, no estan en seguimiento. Entonces:\n\n\nBash\n\n~/Documents/repo_cchiquitovalencia$ git init\n\n\n\nOutput\n\nInicializado repositorio Git vacío en /home/cchvcpcj/Documents/repo_cchiquitovalencia/.git/\n\nRevisemos el estado:\n\n\nBash\n\n~/Documents/repo_cchiquitovalencia$ git status\n\n\n\nOutput\n\nEn la rama master\n\nNo hay commits todavía\n\nArchivos sin seguimiento:\n  (usa \"git add &lt;archivo&gt;...\" para incluirlo a lo que se será confirmado)\n\n    cchiquitovalencia.github.io/\n\nno hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa \"git add\" para hacerles seguimiento)\n\nHago lo que me dice:\n\n\nBash\n\n~/Documents/repo_cchiquitovalencia$ git add cchiquitovalencia.github.io/\n\n\n\nOutput\n\nEn la rama master\n\nNo hay commits todavía\n\nCambios a ser confirmados:\n  (usa \"git rm --cached &lt;archivo&gt;...\" para sacar del área de stage)\n\n    nuevo archivo:  cchiquitovalencia.github.io/.gitignore\n    nuevo archivo:  cchiquitovalencia.github.io/.nojekyll\n...\n    nuevo archivo:  cchiquitovalencia.github.io/posts/_metadata.yml\n    nuevo archivo:  cchiquitovalencia.github.io/resources.qmd\n    nuevo archivo:  cchiquitovalencia.github.io/styles.css\n    nuevo archivo:  cchiquitovalencia.github.io/styles.scss\n\nAhora, mientras escribo este post en un documento de Quarto dentro de una sesion de Rstudio, puedo abrir otra para revisar que todo este en orden: poder hacer commits y push desde local a Github.\n\nBueno, aquí mi primer problema:\n\nEl formato ssh no tiene soporte? Como siempre, cuando hay problemas, vamos a stack overflow: “push git unsupported gpg.format ssh”, unos blogs más tarde, la respuesta fue:\n\nEn este momento, me acordé que en la manana estaba trabajando en otro post sobre Git, y revise la version:\n\nEntonces le hice caso a Martin Thoma. Miremos lo que tengo:\n\n\nBash\n\ngit config --list\n\n\n\nOutput\n\ncredential.helper=cache\ncredential.helper=\ncredential.helper=/usr/local/share/gcm-core/git-credential-manager-core\ncredential.credentialstore=gpg\nuser.name=cchiquitovalencia\nuser.email=cchiquito.valencia@pm.me\nuser.signingkey=/home/cchvcpcj/.ssh/id_ed25519.pub\ncredential.https://dev.azure.com.usehttppath=true\ncommit.gpgsign=false\ngpg.format=ssh\n\nLuego de modificar el .gitconfig\n\nAhora, PUSH!: y me solicita un PASSPHRASE.\n\nClaro que algo falló, no me acuerdo del passphrase! Luego de investigar un poco sobre como recuperar mi passphrase: puedes revisar en donde esta disponible tu llave y puedes crear el certificado de revocacion de tu llave publica, pero necesitas acordarte del passphrase!\nY luego segui revisando otro poco mas, y como no entendi nada aqui, pues me asegure de no olvidar nunca mas el passphrase.\nAl final lo unico que entendi fue que debia generar otra llave:\n\nDescargué e instalé las herramientas de línea de comandos GPG para mi sistema operativo.\nPuedes confirmar si tienes una version instalada:\n\n\nBash\n\ngpg --version\n\n\n\nOutput\n\ngpg (GnuPG) 2.2.19\nlibgcrypt 1.8.5\nCopyright (C) 2019 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nHome: /home/cchvcpcj/.gnupg\nSupported algorithms:\nPubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\nCipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\n        CAMELLIA128, CAMELLIA192, CAMELLIA256\nHash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\nCompression: Uncompressed, ZIP, ZLIB, BZIP2\n\nAbrí una Terminal.\nGeneré un par de claves GPG. Dado que existen varias versiones de GPG, es posible que debas consultar la página de manual correspondiente para encontrar el comando de generación de claves adecuado.\n\n\nBash\n\ngpg --full-generate-key\n\n\n\nOutput\n\ngpg (GnuPG) 2.2.19; Copyright (C) 2019 Free Software Foundation, Inc.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nPlease select what kind of key you want:\n   (1) RSA and RSA (default)\n   (2) DSA and Elgamal\n   (3) DSA (sign only)\n   (4) RSA (sign only)\n  (14) Existing key from card\nYour selection? 1\n\nRSA keys may be between 1024 and 4096 bits long.\nWhat keysize do you want? (3072) 4096\n\nPlease specify how long the key should be valid.\n         0 = key does not expire\n      &lt;n&gt;  = key expires in n days\n      &lt;n&gt;w = key expires in n weeks\n      &lt;n&gt;m = key expires in n months\n      &lt;n&gt;y = key expires in n years\nKey is valid for? (0) 0\nKey does not expire at all\nIs this correct? (y/N) y\n\n\nFinalmente genero otra llave más porque la que tenia había expirado. Qué tal que hubiera buscado maneras de aligerar la búsqueda de mi llave?, será que al final tendría que haber buscado la manera de ponerla a funcionar luego de expirar?\n\n\nOutput\n\nsec   rsa4096/BE0A7004D70A24F0 2022-03-23 [SC]\n      8D8EDF6C11646AB64D276070BE0A7004D70A24F0\nuid                 [ultimate] cchiquitovalencia (Key to) &lt;cchiquito.valencia@pm.me&gt;\n\nsec   rsa4096/D0A5DB1B2962C681 2024-11-15 [SC]\n      6DA68EDA9FE612269D802528D0A5DB1B2962C681\nuid                 [ultimate] cchiquitovalencia (Acceso para Github) &lt;cchiquito.valencia@pm.me&gt;\nssb   rsa4096/F4AE44B3682F30AE 2024-11-15 [E]\n\nEs necesario registrar la llave en Github, vamos a Configuración:\n\nLa zona de acceso\n\ny nueva llave:\n\nY digitamos título y PUBLIC KEY BLOCK:\n\nPara obtener la llave completa que debemos registrar, ejecutar en la Terminal:\n\n\nBash\n\ngpg --armor --export D0A5DB1B2962C681\n\nCambiando el Key ID para cada llave generada. Ahora tengo esto:\n\nAhora si, ya:\n\nCloné el repositorio que se encuentra alojado en Github a mi equipo local.\nInicié el seguimiento con Git en mi control de versiones al proyecto local.\nActualicé mi version de Git para tener acceso son SSH.\nCreé una llave pública nueva, porque no recordaba que la anterior expiró.\nRegistré la llave nueva a Github para realizar PUSH desde lo local.\n\nEntonces creo un archivo para realizar la prueba, se llama “actualizado.qmd” y contiene lo siguiente.\n\nFinalmente guardo el archivo y le doy commit:\n\nAhora, la hora de la verdad: PUSH! No sin antes decirle a Git que cambie la llave porque al principio teniamos: user.signingkey=/home/cchvcpcj/.ssh/id_ed25519.pub\nEn la Terminal:\n\n\nBash\n\ngit config --global user.signingkey D0A5DB1B2962C681\n\nPUSH!!!!\nPues nada pasó a Github. De alguna manera me pide el usuario, y le digo cchiquitovalencia, luego me pide clave, pero de un correo que no tengo registado en Github. Solo tengo registrado cchiquito.valencia@pm.me, entonces pienso que algo tiene que ver con el “credential.manager”:\n\n\nBash\n\ngit-credential-manager configure\n\n\n\nOutput\n\nbash: git-credential-manager: command not found\n\nPues a instalarlo se dijo:\n\nY así:\n\n\nBash\n\nsudo dpkg -i /home/cchvcpcj/Downloads/gcm-linux_amd64.2.6.0.deb\n\n\n\nOutput\n\nSeleccionando el paquete gcm previamente no seleccionado.\n(Leyendo la base de datos ... 419408 ficheros o directorios instalados actualmente.)\nPreparando para desempaquetar .../gcm-linux_amd64.2.6.0.deb ...\nDesempaquetando gcm (2.6.0) ...\nConfigurando gcm (2.6.0) ...\n\nAhora sí:\n\n\nBash\n\ngit-credential-manager configure\n\n\n\nOutput\n\nConfiguring component 'Git Credential Manager'...\nConfiguring component 'Azure Repos provider'...\n\nReviso la configuracion:\n\n\nBash\n\ngit config --list\n\n\n\nOutput\n\ncredential.helper=cache\ncredential.helper=\ncredential.helper=/usr/local/share/gcm-core/git-credential-manager-core\ncredential.credentialstore=gpg\ncredential.cacheoptions=--timeout 300\ncredential.helper=\ncredential.helper=/usr/local/bin/git-credential-manager\nuser.name=cchiquitovalencia\nuser.email=cchiquito.valencia@pm.me\nuser.signingkey=D0A5DB1B2962C681\ncredential.https://dev.azure.com.usehttppath=true\ncommit.gpgsign=true\n\nAlgunas verificaciones mas tarde, un passphrase muy bien recordado (no lo olvidaré, y me aseguré muy bien de no volver a hacerlo) y finalmente:\n\ny PUSH!!!!!!!!!!\n\n“De nuevo en el negocio.”"
  }
]