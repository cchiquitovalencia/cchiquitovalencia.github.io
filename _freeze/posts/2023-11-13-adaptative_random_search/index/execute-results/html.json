{
  "hash": "0da1c10a263e971c4a40f464d4f14e98",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Adaptative Random Search\"\ndescription: \"Búsqueda aleatoria adaptativa\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Maintenance Manager @ Grupo Integrado de Transporte Masivo S.A.\ndate: 11-13-2023\ncategories: [R, optimización] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2023-11-13-adaptative_random_search/ \nimage: random_search_image_2.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n## Taxonomía\n\nEl algoritmo `Adaptative Random Search` pertenece al conjunto general de enfoques conocidos como `Optimización Estocástica` y `Optimización Global`.\n\nEs un método de búsqueda directa, en el sentido de que no requiere derivadas para para navegar por el espacio de búsqueda. `Adaptative Random Search` es una extensión de los algoritmos `Random Search`.\n\n## Estrategia\n\nEl algoritmo `Adaptative Random Search` fue diseñado para abordar las limitaciones del tamaño de paso fijo en el algoritmo de `Localized Random Search`.\n\nLa estrategia de la `Adaptative Random Search` consiste en realizar paso óptimo necesario para alcanzar el óptimo global en el espacio de búsqueda. Esto se consigue probando y adoptando tamaños de paso menores o mayores sólo si mejoran el rendimiento de la búsqueda.\n\nLa estrategia del algoritmo `Adaptive Step Size Random Search` (la técnica específica revisada) consiste en probar un paso mayor en cada iteración y adoptarlo si mejora el resultado. Los pasos muy grandes se prueban de la misma manera, aunque con una frecuencia mucho menor. Esta estrategia de preferir movimientos grandes tiene por objeto permitir que la técnica escape a los óptimos locales. Los pasos más pequeños se adoptan si no se produce ninguna mejora durante un periodo prolongado.\n\n## Procedimiento\n\n![Pseudocódigo Random Search](psd_adaptative_random_search.png)\n\n## Heurística\n\n`Adaptative Random Search` fue diseñado para dominios de problemas de optimización de funciones continuas.\n\nLos candidatos con igual costo deben considerarse mejoras para permitir que el algoritmo progrese a través de mesetas en la superficie de respuesta.\n\n`Adaptative Random Search` puede adaptar la dirección de búsqueda además del tamaño del paso.\n\nEl tamaño del paso puede adaptarse para todos los parámetros o para cada parámetro individualmente.\n\n## Código\n\nEn el ejemplo, el algoritmo se ejecuta durante un número fijo de iteraciones y devuelve la mejor solución candidata descubierta. El problema del ejemplo es un caso de optimización de una función continua que busca\n\n$min f(x)$ donde $f = ∑_{i=1}^n X_i^2$, $-5.0<=x_i<=5.0$ y $n=2$.\n\nLa solución óptima para esta función es $(v_0,...,v_{n-1})=0.0$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definir la función objetivo\nobjective_function <- function(vector) {\n    return(sum(vector^2))\n}\n\n# Generar un número aleatorio en el intervalo [min, max]\nrand_in_bounds <- function(min, max) {\n    return(min + ((max-min) * runif(1)))\n}\n\n# Generar un vector aleatorio en el espacio de búsqueda\nrandom_vector <- function(minmax) {\n    #minmax <- matrix(bounds,nrow = problem_size, ncol = problem_size, byrow = FALSE)\n    return(runif(length(minmax), min = minmax[,1], max = minmax[,2]))\n}\n\n# Dar un paso en una dirección aleatoria\ntake_step <- function(minmax, current, step_size) {\n    position <- numeric(length(current))\n    for (i in 1:(length(current)/problem_size)) {\n        min <- max(minmax[i,1], current[i]-step_size)\n        max <- min(minmax[i,2], current[i]+step_size)\n        position[i] <- rand_in_bounds(min, max)\n    }\n    return(position)\n}\n\n# Dar un paso grande en una dirección aleatoria\nlarge_step_size <- function(iter, step_size, s_factor, l_factor, iter_mult) {\n    if (iter > 0 && iter %% iter_mult == 0) {\n        return(step_size * l_factor)\n    } else {\n        return(step_size * s_factor)\n    }\n}\n\n# Dar un paso y un gran paso en direcciones aleatorias\ntake_steps <- function(bounds, current, step_size, big_stepsize) {\n    step <- list()\n    big_step <- list()\n    step$vector <- take_step(bounds, current$vector, step_size)\n    step$cost <- objective_function(step$vector)\n    big_step$vector <- take_step(bounds, current$vector, big_stepsize)\n    big_step$cost <- objective_function(big_step$vector)\n    return(list(step, big_step))\n}\n\n# Inicializar un dataframe para almacenar los resultados\nresults <- data.frame(iteration = integer(), cost = numeric())\n\n# Realizar la búsqueda aleatoria adaptativa\nsearch <- function(max_iter, bounds, init_factor, s_factor, l_factor, iter_mult, max_no_impr) {\n    step_size <- (bounds[1,2]-bounds[1,1]) * init_factor\n    current <- list()\n    current$vector <- random_vector(bounds)\n    current$cost <- objective_function(current$vector)\n    count <- 0\n    for (iter in 1:max_iter) {\n        big_stepsize <- large_step_size(iter, step_size, s_factor, l_factor, iter_mult)\n        steps <- take_steps(bounds, current, step_size, big_stepsize)\n        if (steps[[1]]$cost <= current$cost || steps[[2]]$cost <= current$cost) {\n            if (steps[[2]]$cost <= steps[[1]]$cost) {\n                step_size <- big_stepsize\n                current <- steps[[2]]\n            } else {\n                current <- steps[[1]]\n            }\n            count <- 0\n        } else {\n            count <- count + 1\n            if (count >= max_no_impr) {\n                step_size <- step_size / s_factor\n                count <- 0\n            }\n        }\n        # Almacenar los resultados en el dataframe\n        results <<- rbind(results, data.frame(iteration = iter, cost = current$cost))\n    }\n    return(current)\n}\n\n# Configuración del problema\nproblem_size <- 2\nbounds <- matrix(c(-5, 5), nrow = problem_size, ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iter <- 100\ninit_factor <- 0.05\ns_factor <- 1.3\nl_factor <- 3.0\niter_mult <- 10\nmax_no_impr <- 30\n\n# Ejecutar el algoritmo\nbest <- search(max_iter, bounds, init_factor, s_factor, l_factor, iter_mult, max_no_impr)\n```\n:::\n\n\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\n# Crear modificaciones al plot\ncrear_tema <- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(results, aes(x = iteration, y = cost)) +\n    geom_line() +\n    labs(title = \"Progreso de la función objetivo\", \n         x = \"Iteración\", y = \"Costo\")+\n    crear_tema()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graficar-1.png){width=672}\n:::\n:::\n\n\n\nLa solución óptima es entonces:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbest$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0.1144359 -0.1796417  0.0000000  0.0000000\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}