{
  "hash": "f847a17555c8e617c51670ecb6e6334d",
  "result": {
    "markdown": "---\ntitle: \"Variable Neighborhood Search\"\ndescription: \"Búsqueda de Vencindario Variable\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Maintenance Manager @ Grupo Integrado de Transporte Masivo S.A.\ndate: 12-03-2023\ncategories: [R, optimización] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2023-12-03-variable_neighborhood_search/ \nimage: variable_neighborhood_search_1.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n## Taxonomía\n\n`Variable Neighborhood Search` es una `Metaheurística` y una técnica de `Optimización Global` que administra una técnica de `Local Search`. Está relacionada con el algoritmo de `Iterated Local Search`.\n\n## Estrategia\n\nLa estrategia para `Variable Neighborhood Search` implica la exploración iterativa de vecindarios cada vez más grandes para un óptimo local dado hasta que se localiza una mejora, tras lo cual se repite la búsqueda a través de vecindarios en expansión. La estrategia está motivada por tres principios 1) un mínimo local para una estructura de vecindad puede no ser un mínimo local para una estructura de vecindad diferente, 2) un mínimo global es un mínimo local para todas las estructuras de vecindad posibles, y 3) los mínimos locales están relativamente cerca de los mínimos globales en muchas clases de problemas.\n\n## Procedimiento\n\nEl pseudocódigo muestra que la búsqueda sistemática de vecindarios en expansión para un óptimo local se abandona cuando se alcanza una mejora global (mostrada con el salto Break).\n\n![Pseudocódigo Variable Neighborhood Search](psd_variable_neighborhood_search.png){alt=\"Pseudocódigo Variable Neighborhood Search\"}\n\n## Heurística\n\nSe sugiere el uso de métodos de aproximación (como `Stochastic Hill Climbing`) como procedimiento de `Local Search` para instancias de problemas grandes con el fin de reducir el tiempo de ejecución.\n\n`Variable Neighborhood Search` se ha aplicado a una amplia gama de problemas de optimización combinatoria, así como a problemas de agrupación (clustering) y optimización de funciones continuas.\n\nLa técnica de `Local Search` incrustada debe especializarse según el tipo de problema y la instancia a la que se aplica la técnica.\n\n`Variable Neighborhood Descent` (VND) se puede incrustar en `Variable Neighborhood Search` como un procedimiento de `Local Search` y ha demostrado ser el más eficaz.\n\n## Código\n\nEl algoritmo se aplica a la instancia `Berlin52` de `Travling Salesman Problem` (TSP), tomada de la `TSPLIB`. El problema busca una permutación del orden de visita de las ciudades (llamada tour o recorrido) que minimice la distancia total recorrida. La distancia óptima del recorrido para el caso Berlín52 es de 7.542 unidades.\n\n`Variable Neighborhood Search` utiliza un procedimiento estocástico `2-opt` como `Local Serach` incrustada. El procedimiento elimina dos aristas e invierte la secuencia entre las aristas eliminadas, eliminando potencialmente \"giros\" en el recorrido. La estructura de vecindad utilizada en la búsqueda es el número de veces que se realiza el procedimiento 2-opt en una permutación, entre 1 y 20 veces. La condición de parada para el procedimiento de `Local Search` es un número máximo de iteraciones sin mejora.\n\nLa misma condición de parada es empleada por el procedimiento de orden superior `Variable Neighborhood Search` aunque con un límite inferior en el número de iteraciones sin mejora.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Función para calcular la distancia euclidiana entre dos puntos\neuc_2d <- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Función para calcular el costo de una permutación de ciudades\ncost <- function(perm, cities) {\n    distance <- 0\n    for (i in seq_along(perm)) {\n        c1 <- perm[i]\n        c2 <- if (i == length(perm)) perm[1] else perm[i + 1]\n        distance <- distance + euc_2d(cities[c1, ], cities[c2, ])\n    }\n    return(distance)\n}\n\n# Función para generar una permutación aleatoria de las ciudades\nrandom_permutation <- function(cities) {\n    return(sample(nrow(cities)))\n}\n\n# Función para realizar una operación de dos-opt estocástica en una permutación\nstochastic_two_opt <- function(perm) {\n    c1 <- sample(length(perm), 1)\n    exclude <- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 <- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 <- sample(length(perm), 1)\n    }\n    if (c2 < c1) {\n        temp <- c1\n        c1 <- c2\n        c2 <- temp\n    }\n    perm[c1:c2] <- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Función para realizar una búsqueda local en el espacio de las permutaciones\nlocal_search <- function(best, cities, max_no_improv, neighborhood) {\n    count <- 0\n    repeat {\n        candidate <- list()\n        candidate$vector <- stochastic_two_opt(best$vector)\n        candidate$cost <- cost(candidate$vector, cities)\n        if (candidate$cost < best$cost) {\n            count <- 0\n            best <- candidate\n        } else {\n            count <- count + 1\n        }\n        if (count >= max_no_improv) break\n    }\n    return(best)\n}\n\n# Función de búsqueda principal\nsearch <- function(cities, neighborhoods, max_no_improv, max_no_improv_ls) {\n    best <- list()\n    best$vector <- random_permutation(cities)\n    best$cost <- cost(best$vector, cities)\n    iter <- 0\n    count <- 0\n    stop_loop <- FALSE\n    # Creamos un dataframe para guardar las soluciones\n    solutions <- data.frame(iteration=integer(), cost=double())\n    for (neigh in neighborhoods) {\n        if (stop_loop) {\n            break\n        }\n        candidate <- list()\n        candidate$vector <- best$vector\n        for (i in seq_len(neigh)) {\n            candidate$vector <- stochastic_two_opt(candidate$vector)\n        }\n        candidate$cost <- cost(candidate$vector, cities)\n        candidate <- local_search(candidate, cities, max_no_improv_ls, neigh)\n        cat(\" > iteration\", iter + 1, \", neigh=\", neigh, \", best=\", best$cost, \"\\n\")\n        iter <- iter + 1\n        # Guardamos la solución en el dataframe\n        solutions <- rbind(solutions, data.frame(iteration=iter, cost=best$cost))\n        if (candidate$cost < best$cost) {\n            best <- candidate\n            count <- 0\n            cat(\"New best, restarting neighborhood search.\\n\")\n        } else {\n            count <- count + 1\n        }\n        if (count >= max_no_improv) {\n            stop_loop <- TRUE\n        }\n    }\n    return(solutions)\n}\n\n# Configuración del problema\nberlin52 <- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,\n                     300,465,520,585,480,415,835,625,975,580,\n                     1215,245,1320,315,1250,400,660,180,410,250,\n                     420,555,575,665,1150,1160,700,580,685,595,\n                     685,610,770,610,795,645,720,635,760,650,475,\n                     960,95,260,875,920,700,500,555,815,830,485,\n                     1170,65,830,610,605,625,595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_no_improv <- 50\nmax_no_improv_ls <- 70\nneighborhoods <- 1:20\n\n# Ejecutar el algoritmo\nbest <- search(berlin52, neighborhoods, max_no_improv, max_no_improv_ls)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n > iteration 1 , neigh= 1 , best= 31074 \nNew best, restarting neighborhood search.\n > iteration 2 , neigh= 2 , best= 12196 \nNew best, restarting neighborhood search.\n > iteration 3 , neigh= 3 , best= 11001 \n > iteration 4 , neigh= 4 , best= 11001 \n > iteration 5 , neigh= 5 , best= 11001 \nNew best, restarting neighborhood search.\n > iteration 6 , neigh= 6 , best= 10148 \n > iteration 7 , neigh= 7 , best= 10148 \n > iteration 8 , neigh= 8 , best= 10148 \n > iteration 9 , neigh= 9 , best= 10148 \n > iteration 10 , neigh= 10 , best= 10148 \nNew best, restarting neighborhood search.\n > iteration 11 , neigh= 11 , best= 9977 \n > iteration 12 , neigh= 12 , best= 9977 \n > iteration 13 , neigh= 13 , best= 9977 \n > iteration 14 , neigh= 14 , best= 9977 \n > iteration 15 , neigh= 15 , best= 9977 \n > iteration 16 , neigh= 16 , best= 9977 \n > iteration 17 , neigh= 17 , best= 9977 \n > iteration 18 , neigh= 18 , best= 9977 \n > iteration 19 , neigh= 19 , best= 9977 \n > iteration 20 , neigh= 20 , best= 9977 \n```\n:::\n:::\n\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\ncrear_tema <- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(best, aes(x=iteration, y=cost)) +\n    geom_line() +\n    labs(title=\"Progreso del costo a lo largo de las iteraciones\", x=\"Iteración\", y=\"Costo\")+\n    crear_tema()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graficar-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}