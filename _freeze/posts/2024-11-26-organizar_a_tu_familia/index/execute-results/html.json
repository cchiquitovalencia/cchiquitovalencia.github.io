{
  "hash": "b107069f1c6e935d78458aee7e553d3b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"El secreto para organizar a tu familia\"\ndescription: \"Asignar dormitorios\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Independent @ CHV\ndate: 11-26-2024\ncategories: [Git] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2024-11-26-organizar_a_tu_familia/ \nimage: asignar.jpeg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n## Introducción\n\nDesde hace varios años mi esposa y yo habíamos querido organizar unas vacaciones familiares. Estoy hablando de vacaciones familiares en grande! Logramos reservar un espacio con la capacidad suficiente y una ubicación central para los diferentes planes en la region. Ahora el lío era cuadrar dónde iba a dormir cada uno.\n\nLas personas confirmadas fueron:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlistado <- read.csv(\"./listado.csv\")\n\nlistado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      persona edad grupo\n1       Nelsy   75     1\n2    Hernando   74     2\n3      Ofelia   63     3\n4     Liliana   63     4\n5  John Jairo   61     4\n6       Jimmy   45     5\n7        Luis   42     6\n8       Linda   41     6\n9    Mercedes   40     5\n10     Sandra   35     3\n11  Estefania   33     7\n12       Juan   31     7\n13   Cristian   32     8\n14    Claudia   31     8\n15    Daniela   30     4\n16     Felipe   17     6\n17    Nicolas   11     5\n18   Emiliano    8     7\n19    Gabriel    4     5\n20       Emma    2     7\n```\n\n\n:::\n:::\n\n\n\nEn el lugar habían 3 tipos de cama: sencilla, doble y camarote. Las camas estaban distribuidas en 8 dormitorios. Solo 3 dormitorios contaban con baño privado.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndormitorios <- read.csv(\"./dormitorios.csv\")\n\ndormitorios\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  dormitorio sencilla doble camarote wc\n1          1        1     0        2  0\n2          2        1     0        2  0\n3          3        1     0        2  0\n4          4        1     0        1  1\n5          5        4     0        0  0\n6          6        0     1        0  1\n7          7        1     0        2  0\n8          8        1     0        2  1\n9       sala        1     0        0  0\n```\n\n\n:::\n:::\n\n\n\nAquí realmente en la sala habia un sofa cama, pero sirve como un espacio para dormir una persona. Los camarotes, cada uno cuenta con 2 espacios para dormir.\n\n## Nuestro reto: acomodar\n\nComo reglas básicas pensamos:\n\n1.  Los grupos familiares no se deben mezclar entre sí.\n\n2.  Los matrimonios necesitan dormir en el mismo dormitorio.\n\n3.  Los niños menores, en caso de ser necesario, pueden mezclarse.\n\n4.  Por condiciones de salud, Ofelia y John Jairo deben dormir en un dormitorio con baño.\n\n## Modelo de asignación\n\nLa idea es introducir una variable binaria $x_{i,j}$ que sea $1$ si una persona $i$ es asignada al dormitorio $j$. Como un objetivo (y puede ser el caso ajustarse a cualquier otro) podemos tratar de garantizar las reglas otorgando un peso. Aqui claramente la capacidad del lugar es suficiente para la cantidad de personas en la familia.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ompr)\nlibrary(ompr.roi)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndormitorios <- dormitorios %>% \n        mutate(capacidad = sencilla * 1 + doble * 2 + camarote * 2)\n\ndormitorios\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  dormitorio sencilla doble camarote wc capacidad\n1          1        1     0        2  0         5\n2          2        1     0        2  0         5\n3          3        1     0        2  0         5\n4          4        1     0        1  1         3\n5          5        4     0        0  0         4\n6          6        0     1        0  1         2\n7          7        1     0        2  0         5\n8          8        1     0        2  1         5\n9       sala        1     0        0  0         1\n```\n\n\n:::\n:::\n\n\n\nVamos a establecer, como administradores, las reglas basicas en cuanto a preferencias. A cada uno de los integrantes vamos a definirle 3 dormitorios que cumplan con nuestras reglas.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definir el orden de las preferencias por persona\ndatos_preferencias <- setNames(\nlist(c(2,3,4), # Nelsy no tiene problema\n     c(2,3,4), # Hernando no tiene problema\n     c(4,6,8), # Ofelia requiere un baño\n     c(4,8,6), # Liliana va con su esposo en dormitorio con baño\n     c(4,6,8), # John requiere un baño\n     c(3,7,8), # Jimmy quiere dormir con toda su familia\n     c(2,3,7), # Luis quiere dormir con su padre e hijo también\n     c(2,3,7), # Linda quiere dormir con su esposo\n     c(3,7,8), # Mercedes quiere dormir con toda su familia\n     c(4,6,8), # Sandra quiere dormir con la madre\n     c(3,7,8), # Estefania quiere dormir con toda su familia\n     c(3,7,8), # Juan quiere dormir con toda su familia\n     c(2,4,6), # Cristian quiere dormir con su esposa\n     c(2,4,6), # Claudia quiere dormir con su esposo\n     c(4,8,5), # Daniela quiere dormir sola o con sus padres\n     c(4,8,5), # Felipe quiere dormir solo o con sus padres\n     c(5,7,8), # Nicolas no quiere dormir solo o con sus padres\n     c(5,7,8), # Emiliano no quiere dormir solo o con sus padres\n     c(3,7,8), # Gabriel quiere dormir con sus padres\n     c(3,7,8) # Emma quiere dormir con sus padres\n     )\n,\nlistado$personas\n)\n\n# Definir funcion para extraer vector de preferencia por persona\nbuscar_preferencia <- function(persona) datos_preferencias[[persona]]\n\n# Entregar prefencia con el par persona-dormitorio(hab)\npreferencias <- function(persona, hab) {\n        p <- which(as.numeric(hab) == buscar_preferencia(as.numeric(persona)))\n        as.integer(if (length(p) == 0) {\n                -100000\n        } else {\n                p\n        })\n}\n```\n:::\n\n\n\nPodríamos haber definido 4 o 5 opciones, pero el punto es entender que, para éste ejemplo, lo que hemos hecho es establecer nosotros, administradores, las prioridades. Podríamos haber hecho una encuesta, enviarle un link a cada participante, para recolectar los datos y de esa forma obtener otros valores. Seguramente la solución del modelo no apuntaría a las reglas básicas que establecimos con mi esposa, y eso esta bien, es una solución mas, otra forma de resolver el problema de asignación.\n\n$$\nmaximixar ∑_{i=1}^{n}∑_{j=1}^{m}preferencias_{i,j} · x_{i,j}\n$$\n\n$$\nsujeto ∑_{i=1}^{n}x_{i,j}≤capacidad_{j}, j=1,...,m\n$$\n\n$$\n∑_{j=1}^{m}x_{i,j}=1, i=1,...,n\n$$\n\n$$\nx_{i,j}∈❴0,1❵,i=1,...,nj=1,...,m\n$$\n\nEn R seria:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npersonas <- length(listado$persona)\nhab <- length(dormitorios$dormitorio)\n\nmodelo <- MIPModel() %>% \n        \n        # 1 si la persona i se asigna al dormitorio j\n        add_variable(x[i,j], i = 1:personas, j = 1:hab, type = \"binary\") %>% \n        \n        # maximixar las preferencias\n        set_objective(sum_over(preferencias(i,j) * x[i,j], i = 1:personas, j = 1:hab), sense = c(\"max\")) %>% \n        \n        # no podemos exceder la capacidad de algun dormitorio\n        add_constraint(sum_over(x[i,j], i = 1:personas) <= dormitorios$capacidad[j], j = 1:hab) %>% \n        \n        # cada persona debe asignarse a un dormitorio\n        add_constraint(sum_over(x[i,j], j = 1:hab) == 1, i = 1:personas) %>% \n        \n        # los matrimonios no pueden dormir separados\n        add_constraint(x[4,j] == x[5,j], j = 1:hab) %>% \n        add_constraint(x[6,j] == x[9,j], j = 1:hab) %>% \n        add_constraint(x[7,j] == x[8,j], j = 1:hab) %>% \n        add_constraint(x[11,j] == x[12,j], j = 1:hab) %>% \n        add_constraint(x[13,j] == x[14,j], j = 1:hab) \n\nmodelo\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMixed integer linear optimization problem\nVariables:\n  Continuous: 0 \n  Integer: 0 \n  Binary: 180 \nModel sense: maximize \nConstraints: 74 \n```\n\n\n:::\n:::\n\n\n\n### Solución\n\nUsamos GLPK y Symphony para resolver el modelo:\n\n::: panel-tabset\n#### Solver GLPK\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ROI.plugin.glpk)\n\nresultado_glpk <- solve_model(modelo, with_ROI(solver = \"glpk\", verbose = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SOLVER MSG>  ----\nGLPK Simplex Optimizer, v4.65\n74 rows, 180 columns, 450 non-zeros\n      0: obj =  -0.000000000e+00 inf =   2.000e+01 (20)\n     24: obj =  -1.499995000e+06 inf =   0.000e+00 (0)\n*    92: obj =   4.900000000e+01 inf =   0.000e+00 (0)\nOPTIMAL LP SOLUTION FOUND\nGLPK Integer Optimizer, v4.65\n74 rows, 180 columns, 450 non-zeros\n180 integer variables, all of which are binary\nInteger optimization begins...\nLong-step dual simplex will be used\n+    92: mip =     not found yet <=              +inf        (1; 0)\n+   105: >>>>>   4.900000000e+01 <=   4.900000000e+01   0.0% (6; 0)\n+   105: mip =   4.900000000e+01 <=     tree is empty   0.0% (0; 11)\nINTEGER OPTIMAL SOLUTION FOUND\n<!SOLVER MSG> ----\n```\n\n\n:::\n:::\n\n\n\n#### Solver Symphony\n\n\n\n\n```{.r .cell-code}\nlibrary(ROI.plugin.symphony)\n\nresultado_symphony <- solve_model(modelo, with_ROI(solver = \"symphony\", verbosity = 1))\n```\n\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define funcion para extraer datos de solucion\nentrega_hab <- function(solucion){\n        solucion %>% \n                get_solution(x[i,j]) %>%\n                filter(value > .9) %>%  \n                select(i, j) %>% \n                rowwise() %>% \n                mutate(ranking_preferencia = preferencias(as.numeric(i), as.numeric(j)), \n                       eleccion_administrador = paste0(buscar_preferencia(as.numeric(i)), collapse = \",\")) %>% \n                ungroup %>% \n                rename(persona = i,\n                       dormitorio = j)\n}\n\n# Guardamos la informacion por modelo\nopcion_glpk <- entrega_hab(resultado_glpk) \nopcion_symphony <- entrega_hab(resultado_symphony) \n```\n:::\n\n\n\n::: panel-tabset\n#### Resultados con solver GLPK\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopcion_glpk\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 4\n   persona dormitorio ranking_preferencia eleccion_administrador\n     <int>      <int>               <int> <chr>                 \n 1       1          3                   2 2,3,4                 \n 2       7          3                   2 2,3,7                 \n 3       8          3                   2 2,3,7                 \n 4       2          4                   3 2,3,4                 \n 5      13          4                   2 2,4,6                 \n 6      14          4                   2 2,4,6                 \n 7      15          5                   3 4,8,5                 \n 8      16          5                   3 4,8,5                 \n 9       4          6                   3 4,8,6                 \n10       5          6                   2 4,6,8                 \n11       6          7                   2 3,7,8                 \n12       9          7                   2 3,7,8                 \n13      11          7                   2 3,7,8                 \n14      12          7                   2 3,7,8                 \n15      20          7                   2 3,7,8                 \n16       3          8                   3 4,6,8                 \n17      10          8                   3 4,6,8                 \n18      17          8                   3 5,7,8                 \n19      18          8                   3 5,7,8                 \n20      19          8                   3 3,7,8                 \n```\n\n\n:::\n:::\n\n\n\n#### Resultados con solver Symphony\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopcion_symphony\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 4\n   persona dormitorio ranking_preferencia eleccion_administrador\n     <int>      <int>               <int> <chr>                 \n 1       2          3                   2 2,3,4                 \n 2       7          3                   2 2,3,7                 \n 3       8          3                   2 2,3,7                 \n 4       1          4                   3 2,3,4                 \n 5      13          4                   2 2,4,6                 \n 6      14          4                   2 2,4,6                 \n 7      15          5                   3 4,8,5                 \n 8      16          5                   3 4,8,5                 \n 9       4          6                   3 4,8,6                 \n10       5          6                   2 4,6,8                 \n11      11          7                   2 3,7,8                 \n12      12          7                   2 3,7,8                 \n13      17          7                   2 5,7,8                 \n14      19          7                   2 3,7,8                 \n15      20          7                   2 3,7,8                 \n16       3          8                   3 4,6,8                 \n17       6          8                   3 3,7,8                 \n18       9          8                   3 3,7,8                 \n19      10          8                   3 4,6,8                 \n20      18          8                   3 5,7,8                 \n```\n\n\n:::\n:::\n\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define funcion para crear graficas\ngraficar_solucion <- function(opcion){\n        merge(listado %>% rowid_to_column(),\n              opcion,\n              by.x = \"rowid\",\n              by.y = \"persona\")  %>% \n                ggplot(aes(rowid, dormitorio, label = persona))+\n                geom_point(size = 3, aes(colour = factor(grupo)))+\n                facet_wrap(~ ranking_preferencia)+\n                ggrepel::geom_text_repel()+\n                theme(legend.position = \"top\")+\n                labs(x = \"ID de persona\")+\n                guides(col = guide_legend(title = \"grupo\"))+\n                scale_color_brewer(palette = \"Accent\")\n}\n```\n:::\n\n\n\n::: panel-tabset\n#### Observa GLPK\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraficar_solucion(opcion_glpk)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graf_glpk-1.png){width=672}\n:::\n:::\n\n\n\n#### Observa Symphony\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraficar_solucion(opcion_symphony)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graf_symphony-1.png){width=672}\n:::\n:::\n\n\n:::\n\nLas asignaciones de dormitorios para las personas son diferentes para cada modelo, aún cuando ambos arrojaron la solución óptima.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado_glpk\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStatus: success\nObjective value: 49\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresultado_symphony\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStatus: success\nObjective value: 49\n```\n\n\n:::\n:::\n\n\n\nComo esas dos soluciones óptimas, podrian existir muchas mas, después de todo éste es un problema de optimización combinatorio.\n\n## Conclusiones\n\nVoy a ir con las dos soluciones a planteárselas a mi familia para nuestras vacaciones. Seguramente el plan no va a ejecutarse al pie de la letra, siguiendo los resultados de la solución obtenida, pero será un punto de partida interesante para organizar la solución definitiva, pues tenemos un problema con 180 variables binarias para jugar.\n\nAdemás, tenemos en ambas soluciones, tenemos dos dormitorios sin usar. esto sucede porque:\n\n-   Dentro de las preferencias establecidas no se eligen todos los dormitorios, dejamos de listar el dormitorio \\# 1.\n\n-   Las restricciones declaradas en el código son suficientes para resolver la maximización de esas preferencias, entonces pueden quedar dormitorios libres.\n\nPodría ser que la función objetivo establecida no se realmente útil para nuestro problema. Sin embargo, existen formas de equilibrar y contrastar problemas de optimización lineal con varios objetivos al tiempo.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}