{
  "hash": "52d51565ac89e95c3a47e9a0a149b1b5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Crear Shiny App\"\ndescription: \"MTTO Serie - Parte 4\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Independent @ CHV\ndate: 01-28-2025\ncategories: [Github, Shiny App] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2025-01-28-dev_mtto_app/\nimage: local_to_github.jpeg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\nVamos a crear una app para nuestro modelo de optimización de mantenimiento que hemos definido [aquí](https://cchiquitovalencia.github.io/posts/2025-01-27-maintenance_management/).\n\n## Crear un proyecto local \n\nEste repositorio va a contener los archivos necesarios para nuestra app.\n\nEntramos a nuestra sesión de RStudio:\n\n1.  **File** -\\> **New Project**\n\n    Con la siguiente ventana emergente:\n\n    ![Opciones para iniciar nuevo proyecto.](images/clipboard-2089501707.png){#fig-1}\n\n    Realmente voy a *comenzar desde cero* la aplicación, por lo que\n\n2.  **New Directory** -\\> **Shiny Application**\n\n    ![Configuración del proyecto.](images/clipboard-1800608861.png){#fig-2}\n\n3.  **Create Project**\n\nMi sesión de RStudio queda así:\n\n![Vista inmediata de la creación del proyecto.](images/clipboard-610318707.png){#fig-3 fig-align=\"center\"}\n\n-   `.Rproj`: es un archivo de configuración para RStudio que contiene información sobre el proyecto, como el directorio de trabajo, los paquetes instalados, las opciones de visualización y los scripts de ejecución.\n\n-   `app.R`: es el archivo principal de un proyecto Shiny que contiene la\n    configuración, la interfaz de usuario y la lógica de negocio de la\n    aplicación.\n\n-   `.gitignore`: es un archivo de configuración para Git que contiene una lista de patrones de archivos y directorios que se deben ignorar por Git.\n\nTen presente que en la esquina superior derecha nos indica el proyecto en el que estamos trabajando `dev_shiny_mtto_app.Rproj`. En la parte inferior izquierda, en la pestaña de Git, tenemos los cambios que hemos hecho hasta que realicemos un `commit`.\n\n## Clonar el repositorio desde local a Github. \n\nPor ahora no voy a modificar el `app.R`, solo quiero montar la infraestructura para ejecutar el workflow.\n\nRevisamos qué tenemos en la Terminal dentro de RStudio:\n\n``` {.bash filename=\"Bash\"}\n~/Documents/shiny_mtto_app/dev_shiny_mtto_app$ git status\n```\n\n``` {.bash filename=\"Output\"}\nEn la rama master\n\nNo hay commits todavía\n\nArchivos sin seguimiento:\n  (usa \"git add <archivo>...\" para incluirlo a lo que se será confirmado)\n\n        .gitignore\n        app.R\n        dev_shiny_mtto_app.Rproj\n\nno hay nada agregado al commit pero hay archivos sin seguimiento presentes (usa \"git add\" para hacerles seguimiento)\n```\n\nComo [aquí](#fig-2) seleccionamos \"**Create a git repository**\", ya hemos iniciado el proceso para subirlo a Github.\n\nEn este [post](https://cchiquitovalencia.github.io/posts/2024-11-18-intro_github/) creamos un repositorio en Github y luego lo clonamos a un repositorio local. Ahora vamos a realizar el proceso al revés, ya creado local vamos a clonarlo a Github.\n\nPodemos incluir todos nuestros archivos con el comando:\n\n``` {.bash filename=\"Bash\"}\n~/Documents/shiny_mtto_app/dev_shiny_mtto_app$ git add .\n```\n\n``` {.bash filename=\"Output\"}\nEn la rama master\n\nNo hay commits todavía\n\nCambios a ser confirmados:\n  (usa \"git rm --cached <archivo>...\" para sacar del área de stage)\n\n        nuevo archivo:  .gitignore\n        nuevo archivo:  app.R\n        nuevo archivo:  dev_shiny_mtto_app.Rproj\n```\n\nYa están bajo seguimiento. Clic en **Commit**:\n\n![Clic en Commit.](images/clipboard-2407796287.png){#fig-4 fig-align=\"center\"}\n\nInsertamos nuestro comentario \"*first commit*\" (buenas prácticas) y obtenemos:\n\n![Resultados commit.](images/clipboard-277284033.png){#fig-5 fig-align=\"center\"}\n\nEn la consola de RStudio ingresamos:\n\n``` {.r filename=\"Console\"}\nusethis::use_github()\n```\n\n``` {.r filename=\"Output\"}\nℹ Defaulting to \"https\" Git protocol.\n✔ Setting active project to\n  \"~/Documents/shiny_mtto_app/dev_shiny_mtto_app\".\n✔ Creating GitHub repository \"cchiquitovalencia/dev_shiny_mtto_app\".\n✔ Setting remote \"origin\" to\n  \"https://github.com/cchiquitovalencia/dev_shiny_mtto_app.git\".\n✔ Pushing \"master\" branch to GitHub and setting \"origin/master\" as upstream branch.\n✔ Opening URL <https://github.com/cchiquitovalencia/dev_shiny_mtto_app>.\n```\n\nSi en este punto has quedado perdido, puedes revisar este [post](https://cchiquitovalencia.github.io/posts/2024-11-20-ejemplo_usarGithub/) para guiarte un poco. Entonces ya tenemos establecido en Github nuestro repositorio creado de manera local:\n\n[![Repositorio creado local en Github.](images/clipboard-1618772576.png){#fig-6 fig-align=\"center\"}](https://github.com/cchiquitovalencia/dev_shiny_mtto_app)\n\n## Desarrollo de Shiny app\n\nManos a la obra: reemplazamos todo lo que contiene nuestro archivo `app.R` con lo siguiente:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(ompr)\nlibrary(ompr.roi)\nlibrary(ROI.plugin.glpk)\nlibrary(ggplot2)\nlibrary(tidyverse)\n\n# Definir UI\nui <- fluidPage(\n        \n        # Título de app\n        titlePanel(\"Planeación de Mantenimiento\"),\n        \n        # Opciones para el modelo\n        fluidPage(\n                sidebarPanel(\n                        numericInput(\"m\", \"Flota\", value = 2, min = 1, max = 5, step = 1),\n                        numericInput(\"H\", \"Periodos\", value = 8, min = 4, max = 12, step = 1),\n                        numericInput(\"D\", \"Demanda\", value = 480, min = 200, max = 1000, step = 20),\n                        numericInput(\"Ui\", \"Periodos entre MTTOs\", value = 3, min = 1, max = 7, step = 1),\n                        numericInput(\"Ti\", \"Horas entre MTTOs\", value = 90, min = 50, max = 200, step = 10),\n                        numericInput(\"xmax\", \"Máximo horas operación\", value = 744, min = 500, max = 1000, step = 66),\n                        actionButton(\"solucionar\", \"Obtener solución!\"),\n                        br(),\n                        actionButton(\"graficar\", \"Graficar solución!\")\n                        , width = 3)\n                ,\n                \n                mainPanel(\n                        h4('Descripción del modelo'),\n                        #verbatimTextOutput(\"periodosMtto\"),\n                        #verbatimTextOutput(\"horasMtto\"),\n                        verbatimTextOutput(\"imprimeModelo\"),\n                        verbatimTextOutput(\"imprimeResultado\"),\n                        plotOutput(\"grafica\")\n                )\n                \n        )\n        \n)\n\n# Definir lógica del servidor para resolver el modelo\nserver <- function(input, output) {\n        \n        # Usado para mostrar variables internas\n        output$periodosMtto <- renderPrint({\n                rep(input$Ui, input$m)\n        })\n        \n        output$horasMtto <- renderPrint({\n                rep(input$Ti, input$m)\n        })\n        \n        # Función para crear modelo planeación\n        crearModelo <- reactive({\n                \n                # Repetir valores ingresados por usuario para Ui y Ti\n                realUi <- rep(input$Ui, input$m)\n                realTi <- rep(input$Ti, input$m)\n                \n                # Definir el modelo con ompr\n                model <- MIPModel() |>\n                        \n                        # Variables\n                        add_variable(y[i, t], i=1:input$m, t=1:input$H, type=\"binary\") |>\n                        add_variable(x[i, t], i=1:input$m, t=1:input$H, type=\"continuous\", lb=0) |>\n                        \n                        # Función objetivo\n                        set_objective(sum_expr(y[i, t], i=1:input$m, t=1:input$H), \"min\") |>\n                        \n                        # Restricciones\n                        add_constraint(sum_expr(x[i, t], i=1:input$m, t=1:input$H) >= input$D) |>\n                        add_constraint(sum_expr(y[i, j], j=tao:(tao+realUi[i])) >= 1, i=1:input$m, tao=1:(input$H-realUi[i])) |>\n                        add_constraint(sum_expr(x[i, j], j=t:(t+u)) <= realTi[i] + realTi[i]*sum_expr(y[i, j], j=t:(t+u)), i=1:input$m, t=1:input$H, u=0:(input$H-t)) |>\n                        add_constraint(x[i, t] + input$xmax*y[i, t] <= input$xmax, i=1:input$m, t=1:input$H)\n                \n                # Devolver el modelo         \n                model\n        })\n        \n        # Función para entregar características del modelo\n        output$imprimeModelo <- renderPrint(crearModelo())\n        \n        # Ejecutar solución del modelo\n        resultado <- eventReactive(\n                input$solucionar, {\n                        \n                        # Activar solver\n                        result <- solve_model(crearModelo(), with_ROI(solver = \"glpk\", verbose = TRUE))\n                        result\n                        \n                })\n        \n        # Función para entregar características de la solución\n        output$imprimeResultado <- renderPrint(resultado())\n        \n        # función para crear gráficas de la solución\n        plotear <- eventReactive(\n                input$graficar, {\n                        \n                        # Graficar solución\n                        gridExtra::grid.arrange(\n                                get_solution(resultado(), y[i,t]) |>\n                                        mutate(Mtto = \"Mant\") |>\n                                        rename(unidad = i, periodo = t) |>\n                                        ggplot()+\n                                        geom_point(aes(periodo, value, color = as.factor(value)), size = 5)+\n                                        facet_grid(unidad~.)+\n                                        hrbrthemes::theme_ipsum()+\n                                        labs(x = \"PERIODO\", y = \"VALOR\", col = \"MTTO\")+\n                                        theme(legend.position = \"top\"),\n\n                                get_solution(resultado(), x[i,t]) |>\n                                        mutate(Horas = \"Opera\") |>\n                                        rename(unidad = i, periodo = t) |>\n                                        ggplot()+\n                                        geom_point(aes(periodo, value, color = as.factor(value)), size = 5)+\n                                        facet_grid(unidad~.)+\n                                        hrbrthemes::theme_ipsum()+\n                                        labs(x = \"PERIODO\", y = \"VALOR\", col = \"OPERA\")+\n                                        theme(legend.position = \"top\"),\n\n                                ncol = 2\n                        )\n                        \n                })\n        \n        output$grafica <- renderPlot(plotear())\n        \n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n```\n:::\n\n\n\nBásicamente establecemos en la `ui` los parámetros que podrían cambiar, con algunos rangos que puede modificar (no pueden ser muy amplios porque el problema de optimización es de tipo **NP-Hard**). Creamos un resumen del tamaño del problema, imprimimos el resultado de la optimización que mostramos cuando el usuario usa un botón, y graficamos la solución con otro botón.\n\nRealmente nuestra app es muy sencilla (aunque el problema que resuelve no lo sea). Es tan sencilla que podría tener detractores de la cultura *DevOps* en cualquier punto. Que sea a prueba de balas no es el punto aquí, sino enviar a producción.\n\nActualizamos nuestro repositorio en Github: `commit` y `push`. Tenemos nuestra app lista para clonar desde Github con [nuestra instancia en AWS](https://cchiquitovalencia.github.io/posts/2025-01-27-start_EC2_instance/).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}