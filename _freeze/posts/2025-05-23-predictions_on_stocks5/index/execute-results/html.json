{
  "hash": "81c53075b8f1a4140a2727cfbd1cbb78",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Más allá de la precisión: Dominando métricas avanzadas para el éxito en el ML\"\ndescription: \"TRADING Serie - Parte 5\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Independent @ CHV\ndate: 04-23-2025\ncategories: [Machine Learning, Trading, Regresión Logística, F1 score, Critical Success Index, Equitable Threat Score, Matthews Correlation Coefficient] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2025-04-23-predictions_on_stocks5/\nimage: advanced.jpeg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\nLa mayoría de las personas confían en la precisión, la exactitud y la cobertura para medir el éxito de los modelos de aprendizaje automático. Sin embargo, **estas métricas resultan miserablemente inadecuadas en escenarios de alta relevancia**, como las predicciones de tornados o la detección de fraudes. Si dominas estas cuatro métricas avanzadas:\n\n-   [F1 score]\n\n-   [Índice crítico de éxito](#índice-crítico-de-éxito) (**CSI**)\n\n-   [Puntuación equitativa de amenazas] (**ETS**)\n\n-   [Coeficiente de correlación de Matthews] (MCC)\n\nte destacarás como un experto en aprendizaje automático.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(myfinance)\nlibrary(caret)\n\n# Función para calcular los resultados tanto de train como de test\ncalculate_results <- function(model, data) {\n  # Realizar predicción\n  predictions <- predict(model, data)\n  \n  # Convertir predicciones en probabilidades\n  probabilities <- 1 / (1 + exp(-predictions))\n  \n  # Determinar la dirección basada en el umbral de 0.5\n  direction <- ifelse(probabilities > 0.5, 1, 0)\n  \n  # Crear la matriz de confusión\n  confusion <- confusionMatrix(factor(direction), factor(data$Direction), mode = \"everything\")\n  \n  # Devolver los resultados\n  list(\n    predicted_direction = direction,\n    confusion_matrix = confusion,\n    predictions = predictions\n  )\n}\n\n# Ejecutar el análisis principal\nmodelo <- main_analysis()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Iniciando el análisis principal...\"\n[1] \"Cargando datos...\"\n[1] \"Datos cargados exitosamente. Número de filas: 4594\"\n[1] \"Creando variables predictoras...\"\n[1] \"Variables predictoras creadas exitosamente.\"\n[1] \"Creando tabla de datos...\"\n[1] \"Tabla de datos creada exitosamente.\"\n[1] \"Dividiendo datos en train y test...\"\n[1] \"Datos divididos exitosamente. Train: 3675 Test: 919\"\n[1] \"Normalizando datos...\"\n[1] \"Normalizados\"\n[1] \"Datos normalizados exitosamente.\"\n[1] \"Construyendo y entrenando el modelo...\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Modelo construido y entrenado exitosamente.\"\n[1] \"Haciendo predicciones para train...\"\n[1] \"Predicciones para train completadas.\"\n[1] \"Evaluando modelo en train...\"\n[1] \"Evaluación en train:\"\n[1] \"Haciendo predicciones para test...\"\n[1] \"Predicciones para test completadas.\"\n[1] \"Evaluando modelo en test...\"\n[1] \"Evaluación en test:\"\n[1] \"Análisis completado exitosamente.\"\n[1] \"Proceso finalizado.\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calcular resultados para train\ntrain_results <- calculate_results(modelo$modelo, modelo$normalized$train)\ntrain_confusion <- train_results$confusion_matrix\n\n# Calcular resultados para test\ntest_results <- calculate_results(modelo$modelo, modelo$normalized$test)\ntest_confusion <- test_results$confusion_matrix\n\nlibrary(tidyverse)\nd2 <- modelo$normalized$test |> \n    as.data.frame() |> \n    mutate(pred_probs = test_results$predictions,\n           pred_classes = factor(test_results$predicted_direction))\n    \n\nlibrary(cutpointr, verbose = FALSE)\nsensitive_case <- cutpointr(\n    data = d2,\n    x = pred_probs,\n    class = Direction,\n    method = minimize_metric,\n    metric = misclassification_cost,\n    cost_fp = 1,\n    cost_fn = 5\n)\n```\n:::\n\n\n\n## F1 score\n\nEmpezaremos con un resumen de las cuatro, comenzando con F1 score, una métrica que equilibra perfectamente la precisión y la cobertura, lo que la hace mejor que ambas por separado.\n\nEl [modelo utilizado](https://cchiquitovalencia.github.io/posts/2025-04-07-predictions_on_stocks/) es una regresión logística con predictores como promedio y desviación estándar de los últimos 10 y 20 días, RSI de 5 y 14 días, MACD y otros. Por supuesto, esto podría reemplazarse por cualquier modelo de clasificación. Una vez entrenado, el modelo predice las probabilidades de alza para los datos de prueba, clasificando a las acciones como sube o no sube en función de un umbral de probabilidad del 50%. Finalmente, se genera una matriz de confusión para evaluar el rendimiento del modelo, proporcionando métricas detalladas como exactitud, precisión, cobertura y, por supuesto, F1 score.\n\nLa F1 score, al igual que la exactitud, es una sola métrica para medir el rendimiento de los modelos. Sin embargo, **es mucho más efectiva para conjuntos de datos desequilibrados**, y aquí está la razón: en escenarios como la detección de fraudes o el diagnóstico de enfermedades raras, donde una clase domina, la exactitud puede ser engañosa. Un modelo que prediga solo la clase mayoritaria puede parecer que funciona bien, incluso si ignora completamente la clase minoritaria. El F1 score aborda esto equilibrando la precisión y la cobertura, lo que la hace ideal para comparar modelos o ajustar hiperparámetros en conjuntos de datos desequilibrados.\n\nLa F1 score se calcula como la media armónica de la precisión y la cobertura.\n\n$$\nF_1=2*\\frac{Precisión*Cobertura}{Precisión+Cobertura}\n$$\n\nLa precisión, o valor predictivo positivo, es la proporción de observaciones positivas correctamente predichas respecto al total de predicciones positivas.\n\n$$\nPrecisión=PPV=\\frac{TP}{TP+FP}\n$$\n\nMientras que la cobertura, o sensibilidad, o tasa de positivos verdaderos, mide la proporción de observaciones positivas correctamente predichas en relación con todos los positivos reales en el conjunto de datos.\n\n$$\nSensibilidad=TRP=\\frac{TP}{TP+FN}\n$$\n\nNuestro modelo muestra una exactitud decente del 93.36%, pero el F1 score del 90.49% indica que se necesita un ajuste de rendimiento. Esto podría significar mejorar la precisión, la cobertura o ambas, dependiendo de los objetivos específicos de tu caso de uso. En nuestro ejemplo, la prioridad debería ser mejorar la cobertura,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsensitive_case |> \n    plot_precision_recall()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\nque es solo del 89.58% mientras que la precisión ya es fuerte, con un 91.43%.\n\nSi bien la capacidad del F1 score para equilibrar la precisión y la cobertura la hace una métrica fundamental en el aprendizaje automático, este equilibrio conlleva un costo: puede no enfatizar lo suficiente la clase positiva en casos de eventos extremadamente raros, como huracanes. Por lo tanto, si el enfoque en los positivos y la ignorancia de los negativos es crítico para el éxito de tu modelo, necesitas explorar el índice crítico de éxito, una métrica específicamente diseñada para estos escenarios extremadamente raros pero de alta relevancia.\n\n## Índice crítico de éxito {#índice-crítico-de-éxito}\n\nTambién conocido como puntuación de amenazas, es una herramienta vital para predecir eventos raros, como tornados y inundaciones. Aquí, nuevamente, un modelo podría lograr una alta exactitud prediciendo principalmente que no ocurre un evento, pero esto haría que se perdieran la mayoría de los desastres, lo que es irónicamente desastroso.\n\nEl secreto del índice crítico de éxito es que ignora completamente los verdaderos negativos, es decir, los momentos en los que no ocurre un evento, y se centra solo en esos raros pero importantes eventos que sí ocurren.\n\n![CSI](CSI.png){#fig-1 fig-align=\"center\" width=\"216\"}\n\nPara calcular el CSI, utilizamos tres partes de la matriz de confusión: positivos verdaderos, falsos positivos y falsos negativos. Específicamente, dividimos las predicciones correctas de eventos entre la suma de predicciones correctas de eventos, alarmas falsas y eventos perdidos.\n\n$$\nCSI=\\frac{TP}{TP+FP+FN}\n$$\n\nPor ejemplo, imagina que tenemos un modelo meteorológico que predice tornados durante un período de tiempo. Si el modelo predijo correctamente 30 tornados, dio cinco falsas alarmas y se perdió dos tornados reales, entonces el CSI sería 0.81 o 81%. Esto significa que el modelo predijo correctamente el 81% de los tornados que realmente ocurrieron.\n\nNuestro modelo tiene:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsi <- function(TP, FP, FN){\n    TP / (TP + FP + FN)\n}\n\nix_csi <- csi(TP = train_confusion$table[1],\n    FP = train_confusion$table[3],\n    FN = train_confusion$table[2])\n```\n:::\n\n\n\nun CSI del 82.64%, lo que significa que si tuviéramos que predecir eventos raros, nos perderíamos casi un cuarto de ellos. Pero, ¿cómo se interpreta el CSI? El CSI oscila entre 0 y 1, donde 1 indica predicciones perfectas y 0 significa que el modelo no hizo ninguna predicción correcta. Un CSI de 0.8 o superior indica un gran rendimiento; un CSI de 0.2 o inferior indica un rendimiento horrible, y todo lo que está entre 0.2 y 0.8 se considera aceptable, dependiendo del tipo de evento que se esté prediciendo.\n\nAquí está la clave: **la utilidad del CSI es altamente dependiente del contexto**. Por ejemplo, un CSI de 0.6 a 0.8 o superior podría esperarse para predicciones de lluvias intensas generalizadas, donde las predicciones suelen ser más fáciles. Por el contrario, un CSI de 0.3 a 0.5 podría ser razonable para advertencias de tornados, porque es tan difícil predecir eventos raros y locales como los tornados.\n\nDado que el CSI ignora los verdaderos negativos, se centra en la clase positiva y penaliza tanto los falsos positivos como los falsos negativos, funciona mucho mejor para conjuntos de datos extremadamente desequilibrados que F1 score. Sin embargo, el CSI tiene un problema con eventos muy raros: incluso la casualidad puede llevar a algunas predicciones correctas, verdaderos positivos, lo que hace que la puntuación de CSI sea mayor de lo necesario. Esto hace que sea difícil comparar puntuaciones de CSI entre diferentes eventos, como huracanes versus inundaciones. La solución es la puntuación equitativa de amenazas, que elimina el efecto de la casualidad en la puntuación.\n\n## Puntuación equitativa de amenazas\n\nLo que hace que la ETS se destaque es su capacidad para comparar el rendimiento de los modelos en eventos con diferentes frecuencias, algo especialmente útil en la predicción del clima. Para calcular la ETS, primero determinamos las `predicciones correctas debido a la casualidad` **(Hc)**, y luego calculamos la ETS de la misma manera que el CSI, pero restando las predicciones correctas por casualidad tanto del numerador como del denominador.\n\n$$\nETS=\\frac{TP-Hc}{TP+FP+FN-Hc}\n$$\n\ndonde\n\n$$\nHc=\\frac{(TP+FN)*(TP+FP)}{Total}\n$$\n\nEste ajuste penaliza a los modelos que tienen éxito por casualidad, lo que hace que la ETS sea más precisa y justa para comparar diferentes eventos raros. Por ejemplo, si predecimos tornados durante un año con 30 verdaderos positivos, cinco falsos positivos y dos falsos negativos durante 365 días, primero calculamos las predicciones correctas por casualidad, y luego la ETS en este caso sería ligeramente inferior al CSI, reflejando su corrección por predicciones correctas por casualidad.\n\nPara simplificar los cálculos futuros, podemos crear una función personalizada en R para calcular CSI, ETS y su diferencia al mismo tiempo.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsi_ets <- function(TP, FP, FN, Total){\n    # Calcular True Positives expected by chance\n    TP_ebc <- ((TP + FP) * (TP + FN)) / Total\n    \n    # Calcular ETS\n    ETS <- (TP - TP_ebc) / (TP + FP + FN - TP_ebc)\n    \n    # Calcular CSI\n    CSI <- (TP) / (TP + FP + FN)\n    \n    # Obtener los resultados\n    resultados <- list(\n        \"CSI (%)\" = CSI * 100,\n        \"ETS (%)\" = ETS * 100,\n        \"CSI - ETS (%)\" = (CSI - ETS) * 100) |> \n        as.tibble() |> \n        mutate_all(~round(., 2))\n    \n    return(resultados)\n}\n\ncsi_ets(TP = train_confusion$table[1],\n    FP = train_confusion$table[3],\n    FN = train_confusion$table[2],\n    Total = 365)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  `CSI (%)` `ETS (%)` `CSI - ETS (%)`\n      <dbl>     <dbl>           <dbl>\n1      82.6      108.           -25.3\n```\n\n\n:::\n:::\n\n\n\nMientras que el CSI y la ETS son valiosos para situaciones específicas, como eventos raros, a veces necesitamos una medida más equilibrada del rendimiento del modelo que considere las cuatro partes de la matriz de confusión, incluyendo los verdaderos negativos. ¿Hay una métrica que haga esto mientras sea considerada más fiable que la exactitud, especialmente para conjuntos de datos desequilibrados? La respuesta es sí: el coeficiente de correlación de Matthews.\n\n## Coeficiente de correlación de Matthews\n\nLo que distingue al MCC de matrices como el CSI y la ETS, que ignoran los verdaderos negativos, es que considera las cuatro partes de la matriz de confusión: verdaderos positivos, verdaderos negativos, falsos positivos y falsos negativos. Esto significa que el MCC no pasa por alto ningún aspecto del rendimiento del modelo.\n\n$$\nMCC=\\frac{TP*TN-FP*FN}{\\sqrt{(TP+FP)*(TP+FN)*(TN+FP)*(TN+FN)}}\n$$\n\nLa principal ventaja del MCC es que solo produce una puntuación alta si el clasificador se desempeña bien tanto en las instancias positivas como en las negativas. Esto lo hace robusto frente al desequilibrio de clases y proporciona una visión más holística del rendimiento del modelo, ya sea que el conjunto de datos esté equilibrado o sesgado. Así que, si quieres la evaluación más completa de tu modelo, el MCC es el camino a seguir.\n\nLa fórmula para el MCC puede ser un poco engorrosa,\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nix_mcc <- function(TP, TN, FP, FN){\n    # Convertimos a numérico para evitar overflow\n    TP <- as.numeric(TP)\n    TN <- as.numeric(TN)\n    FP <- as.numeric(FP)\n    FN <- as.numeric(FN)\n    \n    numerador <- ((TP * TN) - (FP * FN))\n    denominador <- sqrt((TP + FP) * (TP + FN) * (TN + FP) * (TN + FN))\n    \n    numerador/denominador\n}\n\ncoef_mcc <- ix_mcc(TP = train_confusion$table[1],\n                   TN = train_confusion$table[4],\n                   FP = train_confusion$table[3],\n                   FN = train_confusion$table[2])\n```\n:::\n\n\n\nAhora, interpretemos el MCC. Interestantemente, el coeficiente de correlación de Matthews mide la correlación entre las clasificaciones observadas y las predichas. Es por eso que el MCC se interpreta como un coeficiente de correlación, es decir, oscila entre $-1$ (correlación negativa perfecta) y $+1$ (correlación positiva perfecta), con cero significando que no es mejor que una suposición al azar. Por ejemplo, el valor absoluto de 0.853986 en nuestro modelo indica una correlación positiva fuerte entre las predicciones y los resultados reales.\n\nEstas cuatro métricas completas desbloquean una visión profunda del rendimiento de tus modelos, algo que las métricas simples como la exactitud no pueden proporcionar. Pero, **¿sabías que la información que falta puede ser tan valiosa como la que existe?** Para dominar realmente la matriz de confusión en el aprendizaje automático, necesitas entender métricas como la `tasa de información nula`, la `tasa de error nula`, el acuerdo de `Kappa` y los `valores p`. Estas métricas son tan importantes que se colocan en la parte superior de la matriz de confusión. Lamentablemente, la mayoría de las personas las pasan por alto, por razones que no entiendo. Así que, asegúrate de ver este [post](https://cchiquitovalencia.github.io/posts/2025-04-27-predictions_on_stocks6/).\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}