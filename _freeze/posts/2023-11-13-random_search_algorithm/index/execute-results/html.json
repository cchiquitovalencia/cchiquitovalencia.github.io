{
  "hash": "de8376f7964c62000ab74c83310ebd88",
  "result": {
    "markdown": "---\ntitle: \"Random Search\"\ndescription: \"Búsqueda aleatoria\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Maintenance Manager @ Grupo Integrado de Transporte Masivo S.A.\ndate: 11-13-2023\ncategories: [R, optimización] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2023-11-13-random_search_algorithm/ \nimage: random_search_image_5.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n## Taxonomía\n\n`Random Search` pertenece a los campos de la `Optimización Estocástica` y la `Optimización Global`. Es un método de búsqueda directa, no requiere derivadas para buscar en un dominio continuo. Esta enfoque está relacionado con técnicas que proporcionan pequeñas mejoras, como la `Directed Random Search` y la `Adaptative Random Search`.\n\n## Estrategia\n\nLa estrategia de `Random Search` consiste en muestrear soluciones de todo el espacio de búsqueda utilizando una distribución de probabilidad uniforme. Cada muestra futura es independiente de las anteriores.\n\n## Procedimiento\n\n![Pseudocódigo Random Search](psd_random_search.png){alt=\"Pseudocódigo Random Search\"}\n\n## Heurística\n\n`Random Search` es minimalista en el sentido de que sólo requiere una rutina de construcción de soluciones candidatas y una rutina de evaluación de soluciones candidatas, ambas pueden calibrarse con el enfoque.\n\nEn el peor de los casos, el rendimiento de `Random Search` para localizar el óptimo es peor que una `Enumeración` del dominio de búsqueda, dado que `Random Search` no tiene memoria y puede remuestrear a ciegas.\n\n`Random Search` puede devolver una aproximación razonable de la solución óptima en un tiempo razonable con problemas de baja dimensionalidad, aunque el enfoque no se escala bien con tamaño del problema (como el número de dimensiones).\n\nHay que tener cuidado con algunos dominios de problemas para garantizar que la construcción aleatoria de soluciones candidatas no esté sesgada.\n\nLos resultados de una `Random Search` pueden utilizarse para sembrar otra técnica de búsqueda, como una técnica de búsqueda local (como el algoritmo `Hill Climbing`) que se puede utilizar para localizar la mejor solución en la vecindad de la \"buena\" solución candidata.\n\n## Código\n\nEl problema de ejemplo es un caso de optimización continua que busca:\n\n$min f(x)$ donde $f = ∑_{i=1}^n X_i^2$, $-5.0<=x_i<=5.0$ y $n=2$.\n\nLa solución óptima para esta función es $(v_0,…,v_{n-1})=0.0$\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definir la función objetivo\nobjective_function <- function(vector) {\n    return(sum(vector^2))\n}\n\n# Generar un vector aleatorio\nrandom_vector <- function(minmax) {\n    return(runif(length(minmax), min = minmax[,1], max = minmax[,2]))\n}\n\n# Realizar la búsqueda aleatoria\nsearch <- function(search_space, max_iter) {\n    best <- NULL\n    for (iter in 1:max_iter) {\n        candidate <- list()\n        candidate$vector <- random_vector(search_space)\n        candidate$cost <- objective_function(candidate$vector)\n        if (is.null(best) || candidate$cost < best$cost) {\n            best <- candidate\n        }\n       # cat(paste(\" > iteration=\", iter, \", best=\", best$cost, \"\\n\", sep = \"\"))\n    }\n    return(best)\n}\n\n# Configuración del problema\nproblem_size <- 2\nsearch_space <- matrix(c(-5, 5), nrow = problem_size, ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iter <- 1000\n\n# Ejecutar el algoritmo\nbest <- search(search_space, max_iter)\n\n# Imprimir la mejor solución encontrada\ncat(paste(\"Hecho, Mejor solución: c=\", best$cost,\", v=\", best$vector, \"\\n\", sep = \"\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHecho, Mejor solución: c=0.811486079279191, v=-0.608450444415212\n Hecho, Mejor solución: c=0.811486079279191, v=-0.109063517302275\n Hecho, Mejor solución: c=0.811486079279191, v=-0.618307262193412\n Hecho, Mejor solución: c=0.811486079279191, v=0.216968695167452\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}