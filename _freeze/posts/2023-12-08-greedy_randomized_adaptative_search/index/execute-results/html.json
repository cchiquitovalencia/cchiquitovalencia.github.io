{
  "hash": "5964012ccccc6100e394f357dfa2cb0d",
  "result": {
    "markdown": "---\ntitle: \"Greedy Randomized Adaptative Search\"\ndescription: \"Búsqueda Adaptativa Aleatoria y Codiciosa\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Maintenance Manager @ Grupo Integrado de Transporte Masivo S.A.\ndate: 12-08-2023\ncategories: [R, optimización] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2023-12-08-greedy_randomized_adaptative_search/ \nimage: greedy_randomized_adaptative_search.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n## Taxonomía\n\nEl Procedimiento de `Greedy Randomized Adaptative Search` es un algoritmo `Metaheurístico` y de `Optimización Global`, originalmente propuesto para los practicantes de la Investigación de Operaciones. La aplicación iterativa de una técnica de `Local Search` incrustada relaciona el enfoque con `Iterated Local Search` y las técnicas de `Multi-Start`.\n\n## Estrategia\n\nEl objetivo del `Greedy Randomized Adaptative Search` es muestrear repetidamente soluciones codiciosas y, a continuación, utilizar un procedimiento de `Local Search` para refinarlas hasta alcanzar un óptimo local. La estrategia del procedimiento se centra en el mecanismo de construcción por pasos estocásticos y codiciosos que restringe la selección y el orden de inclusión de los componentes de una solución en función del valor que se espera que aporten.\n\n## Procedimiento\n\nSe presenta un pseudocódigo del `Greedy Randomized Adaptative Search` para minimizar una función de costo.\n\n![Pseudocódigo Greedy Randomized Adaptative Search](psd_greedy_randomized_adapatative_search_1.png){alt=\"Pseudocódigo Greedy Randomized Adaptative Search\"}\n\nAdemás, el pseudocódigo de la función de construcción aleatoria codiciosa. La función consiste en la construcción paso a paso de una solución candidata utilizando un proceso de construcción estocástico. La función trabaja construyendo una Lista Restringida de Candidatos (RCL por sus siglas en inglés) que restringe los componentes de una solución (características) que pueden seleccionarse en cada ciclo. La RCL puede limitarse mediante un tamaño explícito o utilizando un umbral $(⍺ ∈ [0,1])$ en el costo de añadir cada característica a la solución candidata actual.\n\n![Pseudocódigo Función de Construcción](psd_greedy_randomized_adapatative_search_2.png)\n\n## Heurística\n\nEl umbral $⍺$ define el grado de avaricia del mecanismo de construcción, donde valores cercanos a 0 pueden ser demasiado codiciosos, y valores cercanos a 1 pueden ser demasiado generalizados.\n\nComo alternativa al uso del umbral $⍺$, el RCL se puede puede limitarse al top $n%$ de las características candidatas que pueden seleccionarse en cada ciclo de construcción.\n\nLa técnica se diseñó para clases de `problemas discretos`, como los problemas de `optimización combinatoria`.\n\n## Código\n\nEl algoritmo se aplica a la instancia `Berlin52` de `Travling Salesman Problem` (TSP), tomada de la `TSPLIB`. El problema busca una permutación del orden de visita de las ciudades (llamada tour o recorrido) que minimice la distancia total recorrida. La distancia óptima del recorrido para el caso Berlín52 es de 7.542 unidades.\n\nLa construcción estocástica y codiciosa por pasos de un recorrido implica la evaluación de las ciudades candidatas por el costo que aportan por ser la siguiente ciudad del recorrido. El algoritmo utiliza un procedimiento estocástico `2-opt` para `Local Search` con un número fijo de iteraciones no mejoradas como como condición de parada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Función para calcular la distancia euclidiana entre dos puntos\neuc_2d <- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Función para calcular el costo de una permutación de ciudades\ncost <- function(perm, cities) {\n    distance <- 0\n    for (i in seq_along(perm)) {\n        c1 <- perm[i]\n        c2 <- if (i == length(perm)) perm[1] else perm[i + 1]\n        distance <- distance + euc_2d(cities[c1, ], cities[c2, ])\n    }\n    return(distance)\n}\n\n# Función para realizar una operación de dos-opt estocástica en una permutación\nstochastic_two_opt <- function(permutation) {\n    perm <- permutation\n    c1 <- sample(length(perm), 1)\n    exclude <- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 <- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 <- sample(length(perm), 1)\n    }\n    if (c2 < c1) {\n        temp <- c1\n        c1 <- c2\n        c2 <- temp\n    }\n    perm[c1:c2] <- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Función para realizar una búsqueda local en el espacio de las permutaciones\nlocal_search <- function(best, cities, max_no_improv) {\n    count <- 0\n    repeat {\n        candidate <- list()\n        candidate$vector <- stochastic_two_opt(best$vector)\n        candidate$cost <- cost(candidate$vector, cities)\n        if (candidate$cost < best$cost) {\n            count <- 0\n            best <- candidate\n        } else {\n            count <- count + 1\n        }\n        if (count >= max_no_improv) break\n    }\n    return(best)\n}\n\n# Función para construir una solución codiciosa aleatorizada\nconstruct_randomized_greedy_solution <- function(cities, alpha) {\n    candidate <- list()\n    candidate$vector <- sample(1:nrow(cities), 1)\n    allCities <- 1:nrow(cities)\n    while (length(candidate$vector) < nrow(cities)) {\n        candidates <- setdiff(allCities, candidate$vector)\n        costs <- sapply(candidates, function(i) euc_2d(cities[candidate$vector[length(candidate$vector)], ], cities[i, ]))\n        rcl <- candidates[which(costs <= min(costs) + alpha * (max(costs) - min(costs)))]\n        candidate$vector <- c(candidate$vector, sample(rcl, 1))\n    }\n    candidate$cost <- cost(candidate$vector, cities)\n    return(candidate)\n}\n\n# Función de búsqueda principal\nsearch <- function(cities, max_iter, max_no_improv, alpha) {\n    best <- NULL\n    cost_progress <- list()  # Lista para registrar el progreso del costo\n    for (iter in seq_len(max_iter)) {\n        candidate <- construct_randomized_greedy_solution(cities, alpha)\n        candidate <- local_search(candidate, cities, max_no_improv)\n        if (is.null(best) || candidate$cost < best$cost) {\n            best <- candidate\n        }\n        cost_progress[[iter]] <- best$cost  # Registrar el costo en la lista\n        cat(\" > iteration\", iter, \", best=\", best$cost, \"\\n\")\n    }\n    return(list(best = best, cost_progress = cost_progress))  # Devolver la mejor solución y el progreso del costo\n}\n\n# Configuración del problema\nberlin52 <- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,300,\n                     465,520,585,480,415,835,625,975,580,1215,245,\n                     1320,315,1250,400,660,180,410,250,420,555,575,\n                     665,1150,1160,700,580,685,595,685,610,770,610,\n                     795,645,720,635,760,650,475,960,95,260,875,920,\n                     700,500,555,815,830,485,1170,65,830,610,605,625,\n                     595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iter <- 50\nmax_no_improv <- 50\ngreediness_factor <- 0.3\n\n# Ejecutar el algoritmo\nresult <- search(berlin52, max_iter, max_no_improv, greediness_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n > iteration 1 , best= 11356 \n > iteration 2 , best= 11356 \n > iteration 3 , best= 11356 \n > iteration 4 , best= 11356 \n > iteration 5 , best= 11356 \n > iteration 6 , best= 10457 \n > iteration 7 , best= 10457 \n > iteration 8 , best= 10457 \n > iteration 9 , best= 10457 \n > iteration 10 , best= 10139 \n > iteration 11 , best= 10139 \n > iteration 12 , best= 10139 \n > iteration 13 , best= 10139 \n > iteration 14 , best= 10139 \n > iteration 15 , best= 10139 \n > iteration 16 , best= 10139 \n > iteration 17 , best= 10139 \n > iteration 18 , best= 10139 \n > iteration 19 , best= 10139 \n > iteration 20 , best= 10139 \n > iteration 21 , best= 10139 \n > iteration 22 , best= 10139 \n > iteration 23 , best= 10139 \n > iteration 24 , best= 10139 \n > iteration 25 , best= 10139 \n > iteration 26 , best= 10139 \n > iteration 27 , best= 10139 \n > iteration 28 , best= 10139 \n > iteration 29 , best= 10139 \n > iteration 30 , best= 10139 \n > iteration 31 , best= 10139 \n > iteration 32 , best= 10139 \n > iteration 33 , best= 10139 \n > iteration 34 , best= 10139 \n > iteration 35 , best= 10139 \n > iteration 36 , best= 10139 \n > iteration 37 , best= 10139 \n > iteration 38 , best= 10139 \n > iteration 39 , best= 10139 \n > iteration 40 , best= 9853 \n > iteration 41 , best= 9853 \n > iteration 42 , best= 9853 \n > iteration 43 , best= 9853 \n > iteration 44 , best= 9853 \n > iteration 45 , best= 9853 \n > iteration 46 , best= 9853 \n > iteration 47 , best= 9853 \n > iteration 48 , best= 9853 \n > iteration 49 , best= 9853 \n > iteration 50 , best= 9853 \n```\n:::\n\n```{.r .cell-code}\nbest <- result$best\ncost_progress <- result$cost_progress\n```\n:::\n\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\ncrear_tema <- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\ndf <- data.frame(iteration = 1:max_iter, cost = unlist(cost_progress))\nggplot(df, aes(x = iteration, y = cost)) +\n    geom_line() +\n    labs(title = \"Progreso del costo a lo largo de las iteraciones\",\n         x = \"Iteración\",\n         y = \"Costo\")+\n    crear_tema()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graficar-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}