{
  "hash": "10335a96851e6d230744dcc7b94a4c22",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Iterated Local serach\"\ndescription: \"Búsqueda Local Iterada\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Maintenance Manager @ Grupo Integrado de Transporte Masivo S.A.\ndate: 11-18-2023\ncategories: [R, optimización] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2023-11-18-iterated_local_search/ \nimage: iterated_local_search_1.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n\n\n## Taxonomía\n\n`Iterated Local Search` es una `Metaheurística` y una técnica de `Optimización Global`. Es una extensión de `Multi-Restar Search` y puede considerarse la base de muchos enfoques de búsqueda en dos fases, como el procedimiento de `Greedy Randomized Adaptive Search Procedure` y `Variable Neighborhood Search`.\n\n## Estrategia\n\nEl objetivo de `Iterated Local Search` es mejorar la `Multi-Restar Search` mediante el muestreo en la vecindad más amplia de soluciones candidatas y el uso de una técnica de `Local Search` para reﬁnar las soluciones a sus óptimos locales. `Iterated Local Search` explora una secuencia de soluciones creadas como perturbaciones de la mejor solución actual, cuyo resultado se reﬁna mediante una heurística integrada.\n\n## Procedimiento\n\n![Pseudocódigo Iterated Local Search](psd_iterated_local_search.png)\n\n## Heurística\n\n`Iterated Local Search` se diseñó para, y se ha aplicado, predominantemente a dominios discretos, como los problemas de optimización combinatoria.\n\nLa perturbación de la mejor solución actual debe estar en un vecindario más allá del alcance de la heurística incorporada y no debe deshacerse fácilmente.\n\nLas perturbaciones demasiado pequeñas hacen que el algoritmo sea demasiado codicioso, mientras que las perturbaciones demasiado grandes hacen que el algoritmo sea demasiado estocástico.\n\nLa heurística incrustada suele ser una técnica de búsqueda local específica del problema.\n\nEl punto de partida de la búsqueda puede ser una solución candidata construida aleatoriamente o mediante una heurística específica del problema (como el vecino más próximo).\n\nLas perturbaciones pueden hacerse de forma determinista, aunque las más comunes son las estocásticas y probabilísticas (adaptativas basadas en el historial).\n\nEl procedimiento puede almacenar tanto o tan poco historial como sea necesario para utilizarlo durante la perturbación y los criterios de aceptación. La ausencia de historial representa un paseo aleatorio en un vecindario más amplio de la mejor solución y es la aplicación más común del enfoque.\n\nEl criterio de aceptación más simple y común es una mejora en el costo de las soluciones candidatas construidas.\n\n## Código\n\nEl algoritmo se aplica a la instancia Berlin52 del `Traveling Saleman Problem` (TSP), tomada de la `TSPLIB`. El problema busca una permutación del orden de visita de las ciudades (llamada recorrido) que minimice la distancia total recorrida. La distancia óptima del recorrido para el caso Berlín52 es de 7.542 unidades.\n\n`Iterated Local Search` se ejecuta durante un número fijo de iteraciones. La implementación se basa en un algoritmo común conﬁguración para el TSP, donde un `'double-bridge move' (4-opt)` se utiliza como la técnica de perturbación, y un `2-opt estocástico` se utiliza como la heurística de búsqueda local incrustada. El `doube-bridge move` consiste en dividir una permutación en 4 partes (a,b,c,d) y volver a unirlas en un orden específico y desordenado (a,d,c,b).\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Función para calcular la distancia euclidiana entre dos puntos\neuc_2d <- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Función para calcular el costo de una permutación de ciudades\ncost <- function(permutation, cities) {\n    distance <- 0\n    for (i in seq_along(permutation)) {\n        c1 <- permutation[i]\n        c2 <- if (i == length(permutation)) permutation[1] else permutation[i + 1]\n        distance <- distance + euc_2d(cities[c1, ], cities[c2, ])\n    }\n    return(distance)\n}\n\n# Función para generar una permutación aleatoria de las ciudades\nrandom_permutation <- function(cities) {\n    return(sample(nrow(cities)))\n}\n\n# Función para realizar una operación de dos-opt estocástica en una permutación\nstochastic_two_opt <- function(permutation) {\n    perm <- permutation\n    c1 <- sample(length(perm), 1)\n    exclude <- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 <- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 <- sample(length(perm), 1)\n    }\n    if (c2 < c1) {\n        c1 <- c2\n        c2 <- c1\n    }\n    perm[c1:c2] <- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Función para realizar una búsqueda local en el espacio de las permutaciones\nlocal_search <- function(best, cities, max_no_improv) {\n    count <- 0\n    repeat {\n        candidate <- list()\n        candidate$vector <- stochastic_two_opt(best$vector)\n        candidate$cost <- cost(candidate$vector, cities)\n        if (candidate$cost < best$cost) {\n            count <- 0\n            best <- candidate\n        } else {\n            count <- count + 1\n        }\n        if (count >= max_no_improv) break\n    }\n    return(best)\n}\n\n# Función para realizar un movimiento de doble puente en una permutación\ndouble_bridge_move <- function(perm) {\n    pos1 <- 1 + sample(floor(length(perm) / 4), 1)\n    pos2 <- pos1 + 1 + sample(floor(length(perm) / 4), 1)\n    pos3 <- pos2 + 1 + sample(floor(length(perm) / 4), 1)\n    return(c(perm[1:pos1], perm[(pos3 + 1):length(perm)], perm[(pos2 + 1):pos3], perm[(pos1 + 1):pos2]))\n}\n\n# Función para perturbar la mejor solución encontrada hasta ahora\nperturbation <- function(cities, best) {\n    candidate <- list()\n    candidate$vector <- double_bridge_move(best$vector)\n    candidate$cost <- cost(candidate$vector, cities)\n    return(candidate)\n}\n\n# Función de búsqueda principal\nsearch <- function(cities, max_iterations, max_no_improv) {\n    best <- list()\n    best$vector <- random_permutation(cities)\n    best$cost <- cost(best$vector, cities)\n    best <- local_search(best, cities, max_no_improv)\n    # Creamos un vector para almacenar el costo del mejor vector en cada iteración\n    best_costs <- numeric(max_iterations)\n    for (iter in seq_len(max_iterations)) {\n        candidate <- perturbation(cities, best)\n        candidate <- local_search(candidate, cities, max_no_improv)\n        if (candidate$cost < best$cost) {\n            best <- candidate\n        }\n        # Almacenamos el costo del mejor vector en la iteración actual\n        best_costs[iter] <- best$cost\n        #print(paste(\" > iteration\", iter, \", best=\", best$cost))\n    }\n    return(list(best = best, best_costs = best_costs))\n}\n\n# Configuración del problema\nberlin52 <- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,300,\n                     465,520,585,480,415,835,625,975,580,1215,245,\n                     1320,315,1250,400,660,180,410,250,420,555,575,\n                     665,1150,1160,700,580,685,595,685,610,770,610,\n                     795,645,720,635,760,650,475,960,95,260,875,920,\n                     700,500,555,815,830,485,1170,65,830,610,605,625,\n                     595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuración del algoritmo\nmax_iterations <- 100\nmax_no_improv <- 50\n\n# Ejecutar el algoritmo\nresult <- search(berlin52, max_iterations, max_no_improv)\n```\n:::\n\n\n\n\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crear un gráfico del progreso de la función objetivo\nlibrary(ggplot2)\n\ndf <- data.frame(iteration = 1:max_iterations, cost = result$best_costs)\n\n# Crear modificaciones al plot\ncrear_tema <- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\n\nggplot(df, aes(x = iteration, y = cost)) +\n    geom_line() +\n    labs(title = \"Progreso del costo a lo largo de las iteraciones\", x = \"Iteración\", y = \"Costo\")+\n    crear_tema()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graficar-1.png){width=672}\n:::\n:::\n\n\n\n\n\nLa solución óptima (con las iteraciones establecidas) es entonces:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult$best$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 18 49 32 35 34  1 44 39 40 36 16 23  7  2 42 30 20 50 29 46 48  5 38 15  6\n[26] 24 37 27 11 52 14 13 47 28 26 25  4 12 51 33 10 43  9  8 19 41 45  3 17 21\n[51] 31 22\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}