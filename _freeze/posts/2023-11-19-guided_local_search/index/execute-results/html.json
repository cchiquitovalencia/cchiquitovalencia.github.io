{
  "hash": "38e5168a0e0c9013887a14164053fb9f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Guided Local serach\"\ndescription: \"B√∫squeda Local Guiada\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Maintenance Manager @ Grupo Integrado de Transporte Masivo S.A.\ndate: 11-19-2023\ncategories: [R, optimizaci√≥n] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2023-11-19-guided_local_search/ \nimage: guided_local_search_1.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n## Taxonom√≠a\n\nEl algoritmo de `Guided Local Search` es una `Metaheur√≠stica` y un algoritmo de `Optimizaci√≥n Global` que hace uso de un algoritmo de `Local Search` embebido. Se trata de una extensi√≥n de los algoritmos de b√∫squeda local como `Hill Climbing` y es similar en estrategia al algoritmo de `Tabu Search` y al algoritmo de `Iterated Local Search`.\n\n## Estrategia\n\nLa estrategia del algoritmo `Guided Local Search` consiste en utilizar penalizaciones para animar a una t√©cnica de `Local Search` a escapar de los √≥ptimos locales y descubrir el √≥ptimo global. Un algoritmo de `Local Search` se ejecuta hasta que se queda atascado en un √≥ptimo local. Las caracter√≠sticas de los √≥ptimos locales se eval√∫an y se penalizan, sus resultados se utilizan en una funci√≥n de costo aumentada empleada por el procedimiento de `Local Search`, que se repite varias veces utilizando los √∫ltimos √≥ptimos locales descubiertos y la funci√≥n de costo aumentada que gu√≠a la exploraci√≥n lejos de las soluciones con caracter√≠sticas presentes en los √≥ptimos locales descubiertos.\n\n## Procedimiento\n\nEl algoritmo de Local Search utilizado por el algoritmo de `Guided Local Search` utiliza una funci√≥n de costo aumentada de la forma $h(s) = g(s)+ ùû¥*‚àë_{i=1}^Mf_i$, donde $h(s)$ es la funci√≥n de costo aumentada, $g(s)$ es la funci√≥n de costo del problema, es el \\`par√°metro de regularizaci√≥n' (un coeficiente para escalar las penalizaciones), $s$ es una soluci√≥n localmente √≥ptima de $M$ caracter√≠sticas, y $f_i$ es la $i$-√©sima caracter√≠stica en la soluci√≥n localmente √≥ptima. La funci√≥n de costos aumentada s√≥lo la utiliza el procedimiento de `Local Search`, mientras que el algoritmo `Guided Local Search` utiliza la funci√≥n de costos espec√≠fica del problema sin aumento.\n\nLas penalizaciones s√≥lo se actualizan para aquellas caracter√≠sticas en una soluci√≥n localmente √≥ptima que maximizan la utilidad, actualizadas a√±adiendo 1 a la penalizaci√≥n para el futuro (un contador). La utilidad de una caracter√≠stica se calcula como $U_{feature} = C_{feature} / (1+P_{feaure})$ , donde $U_{feaure}$ es la utilidad de penalizar una caracter√≠stica (maximizar), $C_{feaure}$ es el costo de la caracter√≠stica y $P_{feature}$ es la penalizaci√≥n actual para la caracter√≠stica.\n\n![Pseudoc√≥digo Guided Local Search](psd_guided_local_search.png)\n\n## Heur√≠stica\n\nEl procedimiento de `Guided Local Search` es independiente del procedimiento de `Local Search` integrado en √©l. Debe identificarse y emplearse un procedimiento de b√∫squeda espec√≠fico del dominio.\n\nEl procedimiento de `Guided Local Search` puede tener que ejecutarse durante miles a cientos de miles de iteraciones, cada iteraci√≥n supone una ejecuci√≥n de un algoritmo de `Local Search` hasta la convergencia.\n\nEl algoritmo se dise√±√≥ para problemas de optimizaci√≥n discretos en los que una soluci√≥n se compone de \"caracter√≠sticas\" evaluables independientemente como la `Optimizaci√≥n Combinatoria`, aunque se ha aplicado a la optimizaci√≥n de funciones continuas modeladas como cadenas binarias.\n\nEl par√°metro $ùû¥$ es un factor de escala para la penalizaci√≥n de caracter√≠sticas que debe estar en la misma proporci√≥n que los costos de la soluci√≥n candidata del problema espec√≠fico al que se aplica el algoritmo. Como tal, el valor para $ùû¥$ debe ser significativo cuando se utiliza dentro de la funci√≥n de costo aumentada (como cuando se a√±ade a un costo de una soluci√≥n candidata en la minimizaci√≥n y se resta de un en el caso de un problema de maximizaci√≥n).\n\n## C√≥digo\n\nEl algoritmo se aplica a la instancia `Berlin52` de `Travling Salesman Problem` (TSP), tomada de la `TSPLIB`. El problema busca una permutaci√≥n del orden de visita de las ciudades (llamada tour o recorrido) que minimice la distancia total recorrida. La distancia √≥ptima del recorrido para el caso Berl√≠n52 es de 7.542 unidades. Se utiliza un algoritmo de `Local Search` 2-opt que selecciona dos puntos en una permutaci√≥n y reconecta el tour, potencialmente desenrollando el tour en los puntos seleccionados. La condici√≥n de parada para 2-opt es un n√∫mero fijo de movimientos no mejorables.\n\nLa ecuaci√≥n para ajustar $ùû¥$ para instancias de TSP es $ùû¥ = ‚ç∫ * costo(optima)/N$ , donde $N$ es el n√∫mero de ciudades, $costo(optima)$ es el costo de un √≥ptimo local encontrado mediante una b√∫squeda local, y $‚ç∫ ‚àà (0,1]$ (alrededor de 0,3 para TSP y 2-opt). El costo de un √≥ptimo local se fij√≥ en el valor aproximado de 15.000 para el TSP de Berl√≠n52. La funci√≥n de utilidad para las caracter√≠sticas (aristas) en el TSP es $U_{edge} = D_{edge}/(1+P_{edge})$ donde $U_{edge}$ es la utilidad de penalizar una arista (maximizar), $D_{edge}$ es el coste de la arista (distancia entre ciudades) y $P_{edge}$ es la penalizaci√≥n actual de la arista.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Funci√≥n para calcular la distancia euclidiana entre dos puntos\neuc_2d <- function(c1, c2) {\n    return(round(sqrt((c1[1] - c2[1])^2 + (c1[2] - c2[2])^2)))\n}\n\n# Funci√≥n para generar una permutaci√≥n aleatoria de las ciudades\nrandom_permutation <- function(cities) {\n    return(sample(nrow(cities)))\n}\n\n# Funci√≥n para realizar una operaci√≥n de dos-opt estoc√°stica en una permutaci√≥n\nstochastic_two_opt <- function(permutation) {\n    perm <- permutation\n    c1 <- sample(length(perm), 1)\n    exclude <- c(c1, if (c1 == 1) length(perm) else c1 - 1, if (c1 == length(perm)) 1 else c1 + 1)\n    c2 <- sample(length(perm), 1)\n    while (c2 %in% exclude) {\n        c2 <- sample(length(perm), 1)\n    }\n    if (c2 < c1) {\n        temp <- c1\n        c1 <- c2\n        c2 <- temp\n    }\n    perm[c1:c2] <- rev(perm[c1:c2])\n    return(perm)\n}\n\n# Funci√≥n para calcular el costo y el costo aumentado de una permutaci√≥n\naugmented_cost <- function(permutation, penalties, cities, lambda) {\n    distance <- 0\n    augmented <- 0\n    for (i in seq_along(permutation)) {\n        c1 <- permutation[i]\n        c2 <- if (i == length(permutation)) permutation[1] else permutation[i + 1]\n        if (c2 < c1) {\n            temp <- c1\n            c1 <- c2\n            c2 <- temp\n        }\n        d <- euc_2d(cities[c1, ], cities[c2, ])\n        distance <- distance + d\n        augmented <- augmented + d + (lambda * penalties[c1, c2])\n    }\n    return(c(distance, augmented))\n}\n\n# Funci√≥n para calcular el costo de un candidato\ncost <- function(cand, penalties, cities, lambda) {\n    costs <- augmented_cost(cand$vector, penalties, cities, lambda)\n    cand$cost <- costs[1]\n    cand$aug_cost <- costs[2]\n    return(cand)\n}\n\n# Funci√≥n para realizar una b√∫squeda local en el espacio de las permutaciones\nlocal_search <- function(current, cities, penalties, max_no_improv, lambda) {\n    current <- cost(current, penalties, cities, lambda)\n    count <- 0\n    repeat {\n        candidate <- list()\n        candidate$vector <- stochastic_two_opt(current$vector)\n        candidate <- cost(candidate, penalties, cities, lambda)\n        if (candidate$aug_cost < current$aug_cost) {\n            count <- 0\n            current <- candidate\n        } else {\n            count <- count + 1\n        }\n        if (count >= max_no_improv) break\n    }\n    return(current)\n}\n\n# Funci√≥n para calcular las utilidades de las caracter√≠sticas\ncalculate_feature_utilities <- function(penal, cities, permutation) {\n    utilities <- numeric(length(permutation))\n    for (i in seq_along(permutation)) {\n        c1 <- permutation[i]\n        c2 <- if (i == length(permutation)) permutation[1] else permutation[i + 1]\n        if (c2 < c1) {\n            temp <- c1\n            c1 <- c2\n            c2 <- temp\n        }\n        utilities[i] <- euc_2d(cities[c1, ], cities[c2, ]) / (1.0 + penal[c1, c2])\n    }\n    return(utilities)\n}\n\n# Funci√≥n para actualizar las penalizaciones\nupdate_penalties <- function(penalties, cities, permutation, utilities) {\n    max_utility <- max(utilities)\n    for (i in seq_along(permutation)) {\n        c1 <- permutation[i]\n        c2 <- ifelse(i == length(permutation), permutation[1], permutation[i + 1])\n        if (c2 < c1) {\n            temp <- c1\n            c1 <- c2\n            c2 <- temp\n        }\n        penalties[c1, c2] <- ifelse(utilities[i] == max_utility, penalties[c1, c2] + 1, penalties[c1, c2])\n    }\n    return(penalties)\n}\n\n# Funci√≥n de b√∫squeda principal\nsearch <- function(max_iterations, cities, max_no_improv, lambda) {\n    current <- list()\n    current$vector <- random_permutation(cities)\n    best <- NULL\n    penalties <- matrix(0, nrow = nrow(cities), ncol = nrow(cities))\n    cost_progress <- data.frame(iteration=integer(), cost=numeric()) # Para llevar el seguimiento del progreso del costo\n    for (iter in seq_len(max_iterations)) {\n        current <- local_search(current, cities, penalties, max_no_improv, lambda)\n        utilities <- calculate_feature_utilities(penalties, cities, current$vector)\n        penalties <- update_penalties(penalties, cities, current$vector, utilities)\n        if (is.null(best) || current$cost < best$cost) {\n            best <- current\n        }\n        cost_progress <- rbind(cost_progress, data.frame(iteration=iter, cost=best$cost)) # Registrar el costo en cada iteraci√≥n\n        #print(paste(\" > iter =\", iter + 1, \", best =\", best$cost, \", aug =\", best$aug_cost))\n    }\n    return(list(best=best, cost_progress=cost_progress)) # Devolver tanto la mejor soluci√≥n como el progreso del costo\n}\n\n\n# Configuraci√≥n del problema\nberlin52 <- matrix(c(565,575,25,185,345,750,945,685,845,655,\n                     880,660,25,230,525,1000,580,1175,650,1130,\n                     1605,620,1220,580,1465,200,1530,5,845,680,\n                     725,370,145,665,415,635,510,875,560,365,\n                     300,465,520,585,480,415,835,625,975,580,\n                     1215,245,1320,315,1250,400,660,180,410,250,\n                     420,555,575,665,1150,1160,700,580,685,595,\n                     685,610,770,610,795,645,720,635,760,650,\n                     475,960,95,260,875,920,700,500,555,815,\n                     830,485,1170,65,830,610,605,625,595,360,1340,725,1740,245), ncol = 2, byrow = TRUE)\n\n# Configuraci√≥n del algoritmo\nmax_iterations <- 150\nmax_no_improv <- 20\nalpha <- 0.3\nlocal_search_optima <- 12000.0\nlambda <- alpha * (local_search_optima / nrow(berlin52))\n\n# Ejecutar el algoritmo\nresult <- search(max_iterations, berlin52, max_no_improv, lambda)\n```\n:::\n\n\n\nRevisamemos el comportamiento del algoritmo para encontrar la soluci√≥n √≥ptima:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\ncrear_tema <- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(result$cost_progress, aes(x=iteration, y=cost)) +\n    geom_line() +\n    labs(title=\"Progreso del costo a lo largo de las iteraciones\", x=\"Iteraci√≥n\", y=\"Costo\")+\n    crear_tema()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graficar-1.png){width=672}\n:::\n:::\n\n\n\nLa soluci√≥n √≥ptima (con las iteraciones establecidas) es entonces:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult$best$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1 22 32 49 36 35 34 44 46 37 40 39 38 24 48  5 15  6  4 25 12 28 26 27 47\n[26] 13 14 52 11 51 43 33 10  9 41  8 19 45  3 18 31  7  2 30 42 17 21 20 29 16\n[51] 50 23\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}