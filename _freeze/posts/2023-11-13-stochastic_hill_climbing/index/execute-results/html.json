{
  "hash": "7b22900538504535773b4879a460c7d0",
  "result": {
    "markdown": "---\ntitle: \"Stochastic Hill Climbing\"\ndescription: \"Escalada estocástica\"\nauthor:\n  - name: Cristian Chiquito Valencia\n    url: https://cchiquitovalencia.github.io/\n    affiliation: Maintenance Manager @ Grupo Integrado de Transporte Masivo S.A.\ndate: 11-13-2023\ncategories: [R, optimización] # self-defined categories\ncitation: \n  url: https://cchiquitovalencia.github.io/posts/2023-11-13-stochastic_hill_climbing/ \nimage: stochastic_hill_climbing_1.jpg\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n## Taxonomía\n\nEl algoritmo `Stochastic Hill Climbing` es un algoritmo de `Optimización Estocástica` y es un algoritmo de `Optimización Local` (a diferencia de la `Optimización Global`). Es una técnica de búsqueda directa, ya que no requiere derivadas del espacio de búsqueda. `Stochastic Hill Climbing` es una extensión de los algoritmos deterministas como el `Simple Hill Climbing` (primer mejor vecino), `Steepest-Ascent Hill Climbing` (mejor vecino), y un padre de enfoques como `Parallel Hill Climbing` y `Random-Restart Hill Climbing`.\n\n## Estrategia\n\nLa estrategia del `Stochastic Hill Climbing` consiste en iterar el proceso de selección aleatoria de un vecino para una solución candidata y aceptarla sólo si da lugar a una mejora. La estrategia se propuso para hacer frente a las limitaciones de las técnicas de ascenso determinista que se atascaban en óptimos locales debido a su avariciosa aceptación de movimientos vecinos.\n\n## Procedimiento\n\n![Pseudocódigo Stochastic Hill Climbing](psd_stochastic_hill_climbing.png)\n\n## Heurística\n\n`Stochastic Hill Climbing` fue diseñado para ser utilizado en dominios discretos con vecinos explícitos, como la optimización combinatoria (en comparación con la optimización de funciones continuas).\n\nLa estrategia del algoritmo puede aplicarse a dominios continuos haciendo uso de un tamaño de paso para definir los vecinos de la solución candidata (como la `Localized Random Search` y la `Fixed Step-Size Random Search`).\n\n`Stochastic Hill Climbing` es una técnica de búsqueda local (en comparación a la búsqueda global) y puede utilizarse para refinar un resultado tras la ejecución de un algoritmo de búsqueda global.\n\nAunque la técnica utiliza un proceso estocástico, aún puede atascarse en óptimos locales.\n\nLos vecinos con mejor o igual costo deben ser aceptados, lo que permite a la técnica navegar a través de mesetas en la superficie de respuesta.\n\nEl algoritmo puede reiniciarse y repetirse una serie de veces veces después de que converja para obtener un resultado mejorado (lo que se denomina `Multiple Restart Hill Climbing`).\n\nEl procedimiento puede aplicarse a varias soluciones candidatas simultáneamente, lo que permite ejecutar varios algoritmos al mismo tiempo (llamado `Parallel Hill Climbing`).\n\n## Código\n\nEl algoritmo se ejecuta durante un número fijo de iteraciones y se aplica a un problema de optimización de cadena binaria denominado 'One Max'. El objetivo de este problema de maximización es preparar una cadena con todos los bits '1', donde la función de costo sólo informa del número de bits en una cadena dada.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Función para calcular la suma de los unos en un vector\nonemax <- function(vector) {\n    return(sum(vector == \"1\"))\n}\n\n# Función para generar una cadena de bits aleatorios\nrandom_bitstring <- function(num_bits) {\n    return(sample(c(\"0\", \"1\"), num_bits, replace = TRUE))\n}\n\n# Función para generar un vecino aleatorio cambiando un bit\nrandom_neighbor <- function(bitstring) {\n    mutant <- bitstring\n    pos <- sample(seq_along(bitstring), 1)\n    mutant[pos] <- ifelse(mutant[pos] == \"1\", \"0\", \"1\")\n    return(mutant)\n}\n\n# Función de búsqueda principal\nsearch <- function(max_iterations, num_bits) {\n    # Inicializar el candidato con un vector aleatorio y calcular su costo\n    candidate <- list()\n    candidate$vector <- random_bitstring(num_bits)\n    candidate$cost <- onemax(candidate$vector)\n    costs <- c()  # Vector para almacenar los costos\n    # Iterar hasta el número máximo de iteraciones\n    for (iter in seq_len(max_iterations)) {\n        # Generar un vecino y calcular su costo\n        neighbor <- list()\n        neighbor$vector <- random_neighbor(candidate$vector)\n        neighbor$cost <- onemax(neighbor$vector)\n        costs <- c(costs, candidate$cost)  # Almacenar el costo de la iteración actual\n        # Si el vecino es mejor o igual, actualizar el candidato\n        if (neighbor$cost >= candidate$cost) {\n            candidate <- neighbor\n        }\n        # Si se encuentra la solución óptima, terminar\n        if (candidate$cost == num_bits) {\n            break\n        }\n    }\n    # Devolver el mejor candidato encontrado y los costos\n    return(list(best = candidate, costs = costs))\n}\n\n# Configuración del problema\nnum_bits <- 64\n\n# Configuración del algoritmo\nmax_iterations <- 1000\n\n# Ejecutar el algoritmo\nresult <- search(max_iterations, num_bits)\nbest <- result$best\ncosts <- result$costs\n```\n:::\n\n\nRevisamemos el comportamiento del algoritmo para encontrar la solución óptima:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n# Crear un gráfico del progreso de la función objetivo\ndf <- data.frame(\n  Iteration = 1:length(costs),\n  Cost = costs\n)\n\n# Crear modificaciones al plot\ncrear_tema <- function() {\n    theme_minimal() +\n        theme(\n            plot.background = element_rect(fill = \"white\", color = NA), \n            panel.grid.major = element_line(color = \"white\", size = 0.2), \n            panel.grid.minor = element_line(color = \"white\", size = 0.2), \n            panel.background = element_rect(fill = \"white\", color = NA), \n            plot.title = element_text(face = \"bold\", size = 14, color = \"#4d6080\"),\n            axis.title = element_text(face = \"bold\", size = 12, color = \"#4d6080\"),\n            axis.text = element_text(size = 10, color = \"#4d6080\"),\n            axis.line = element_line(size = 1.5, colour = \"#de6f41\"), \n            legend.background = element_rect(fill = \"#4d6080\", color = NA), \n            legend.key = element_rect(fill = \"grey90\", color = NA),\n            axis.ticks.x = element_line(color = \"#de6f41\", size = 1),\n            axis.ticks.y = element_line(color = \"#de6f41\", size = 1)\n        )\n}\n\nggplot(df, aes(x = Iteration, y = Cost)) +\n  geom_line(colour = \"steelblue\", size = 1) +\n  labs(\n    title = \"Progreso de la función objetivo\",\n    subtitle = \"Visualización del costo a lo largo de las iteraciones\",\n    x = \"Iteración\",\n    y = \"Costo\"\n  ) +\n  crear_tema()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/graficar-1.png){width=672}\n:::\n:::\n\n\nLa solución óptima es entonces:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult$best$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\n[20] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\n[39] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\n[58] \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}